/**
* Nuance Bootstrap file initializes and loads nuance WebSDK solution. WebSDK relies on clients having the bootstrap file on their page.
* Bootstrap file injects the sandboxed iframe and handles the communication between sandboxed iframe and Bootstrap in the parent page.
* @typedef {Object<string,any>} NuanMessaging
*/
window.NuanMessaging = function() {

	var urlConfigKeys = ["dataCenter", "tagServerName", "vendorUUID"];
	var urlConfigObj = {};
	var DCS = ["west", "east", "eu1", "lax1", "aus"];

	var doc = window.document;
	var pageData = {},siteID, tagServerUrl, launchFileAndPath = "/tagserver/nuanceChat.html";
	var mode = 0, disableC2Crender = false, minimized = false, minimizedCount = 0, usepluginWhenMinimize = false;
	var msgWatchCB, eventCBMap = {}, blockingDetector, dynamicCBQueue = [], funcMap ={},domListeners = [],deviceType,messageWindow,bootstrapC2cInstance;
	var frameID="nuanChatStage", currentFrame;
	var frameCommHandler;

	/**
	@typedef {Object<string,any>} UIConfig	
	*/

	/**
	@typedef {Object<string,any>} config	
	*/
	var config = {

		set mode(val) {
			switch(val.toLowerCase()){
				case "dev":
				case "development":
					mode = 0;
				break;
				case "prod":
				case "production":
					mode = 1;
			}

		},

		get mode() {
			return mode === 0? "dev" : "prod";
		},

		set frameID(val){
			frameID = val;
		},
		get frameID(){
			return frameID;
		},

		/**
		* @property {string} config.siteID - set the site id provided to you by nuance
		*/
		set siteID(val) {
			siteID = val;
		},

		get siteID() {
			return siteID;
		},

		/**
		* @property {function(string,string):void} config.setPageData - add page data key and value
		*/

		setPageData:function(key, val) {
			pageData[key] = val;
		},

		/**
		* @property {function():void} config.resetPageData - clear currently set page data
		*/
		resetPageData:function(){
			pageData = {};
		},

		/**
		 * @typedef {function(MessageEvent):void} watchCB
		 * @callback
		 * @param {MessageEvent} message - postmessage event object 
		 */
		/**
		* @property {watchCB} config.setMessageWatch - client javascript to watch the communication between bootstrap and sandboxed iframe
		*/
		setMessageWatch: function(callback){
			msgWatchCB = callback;
		},

		/**
		* @property {tagServerUrl} config.tagServerUrl - tagserver url
		*/
		get tagServerUrl() {
			var url = ["https://"];
	        url.push(urlConfigObj.tagServerName);
	        if(tagServerUrl) {
	        	url = [tagServerUrl];
	        } else if(DCS.indexOf(urlConfigObj.dataCenter) !== -1) {
	            url.push(".inq.com");
	        } else {
	            url.push(".digital.nuance.com");
	        }
	        return url.join("");
		},

		/**
		* @property {string} config.overrideTagDomain - update the default tagserver url generated by bootstrap 
		*/
		overrideTagDomain:function(url) {
			tagServerUrl = url;
		},

		/**
		* @property {string} config.launchFileAndPath -  update the default sandboxed iframe src path
		*/
		get chatLaunchFileAndPath() {
			return launchFileAndPath;
		},

		set chatLaunchFileAndPath(val) {
			launchFileAndPath = val;
		},

		set pushNotificationID(val) {
			pageData.nuancePushNotificationDeviceId = val;
		},
		get pushNotificationID() {
			return pageData.nuancePushNotificationDeviceId;
		},
		/**
		* @callback eventCB
		* @param {object} eventData -  data associated with the event
		*/
		/**
		* @function
		* @name messagingEvents
		* @param {MessagingEvent} eventType
		* @param {eventCB} callback
		*/
		/**
		* @property {messagingEvents} config.registerForMessagingEvents -  listens to events fired from Nuance Chat framework from withing the sandboxed iframe
		*/
		registerForMessagingEvents:function(eventType, callback){
			if(!eventCBMap[eventType]) {
				eventCBMap[eventType] = [];
			}
			eventCBMap[eventType].push(callback);
		},

		enabledAdBlockDetection: function() {
			this.addBlockEnabled = true;
		},
		/**
		* bootstrap will invoke the provided c2c plugin instance methods when rendering the c2c
		* @property {function(object):void} config.enableCustomC2CRendering
		*/
		enableCustomC2CRendering:function(c2cIntance) {
			disableC2Crender = true;
			bootstrapC2cInstance= c2cIntance;
		},
		enableC2CPluginForMinimizedState:function(c2cIntance) {
			bootstrapC2cInstance = c2cIntance;
		},
		isDragEnabled:function() {
			return this.dragResize || typeof this.dragResize == "undefined" ? true : false;
		},
		disableDrag: function() {
			this.dragResize = false;
		},
		/**
		* Set the json that contains the chat window branding styles and configuration
		* @property {function(UIConfig):void} config.setMessagingUIConfigs
		*/
		setMessagingUIConfigs: function(config) {
			this.uiConfig = config;
		},
		/**
		* @property {function():UIConfig} config.getUIConfig
		*/
		getUIConfig:function() {
			return this.uiConfig;
		},
		/**
		* override chat window width, height and position
		* @property {function(number ,number, WindowPosition):void} config.setFrameConfig
		*/
		setFrameConfig:function(w,h,position) {
			 this.frameW = w;
			 this.frameH = h;
			 if(config.WindowPosition[position]) {
			 	this.framePos = position;	
			 } else {
			 	this.framePos = "LOWER_RIGHT";
			 }
		},
		getVersion: function() {
			return "2.1.0";
		}
	};

	
	/**
	 * @typedef {string} MessagingEvent
	 **/

	/**
	* @property {MessagingEvent} config.Events
	**/
	/**
	* @readonly
 	* @enum {MessagingEvent}
	*/
	config.Events = {
		/** @member {string} */
		ON_RULE_SATISFIED:"onRuleSatisfied",
		/** @member {string} */
		ON_SERVICE_INVITATION:"onServiceInvitation",
		/** @member {string} */
		ON_SERVICE_ENGAGED:"onServiceEngaged",
		/** @member {string} */
		ON_SERVICE_INTERACTED:"onServiceInteracted",
		/** @member {string} */
		ON_SERVICE_MISSED:"onServiceMissed",
		/** @member {string} */
		ON_SERVICE_QUALIFIED:"onExposureQualified",
		/** @member {string} */
		ON_C2C_READY:"onC2CReadyForSDK",
		/** @member {string} */
		ON_C2C_DISPLAYED:"onC2CDisplayed",
		/** @member {string} */
		ON_C2C_STATE_CHANGED:"onC2CStateChanged",
		/** @member {string} */
		ON_C2C_CLICKED:"onC2CClicked",
		/** @member {string} */
		ON_CHAT_REQUESTED:"onChatRequested",
		/** @member {string} */
		ON_CHAT_LAUNCHED:"onChatLaunched",
		/** @member {string} */
		ON_CHAT_SHOWN:"onChatShown",
		/** @member {string} */
		ON_CHAT_CLOSED:"onChatClosed",
		/** @member {string} */
		ON_AGENT_MSG:"onAgentMsg",
		/** @member {string} */
		ON_CUSTOMER_MSG:"onCustomerMsg",
		/** @member {string} */
		ON_AGENT_ASSIGNED:"onAgentAssigned",
		/** @member {string} */
		ON_CHAT_ENGAGED_EVENT:"onChatEngagedEvent",
		/** @member {string} */
		ON_CHAT_EVENT:"onChatEvent",
		/** @member {string} */
		ON_BEFORE_CHAT_CLOSED_EVENT:"onBeforeChatClosed",
		/** @member {string} */
		ON_AGENT_DATAPASS:"onAgentDataPass",
		/** @member {string} */
		ON_RECEIVE_VA_DATAPASS:"onReceiveVADataPass",
		/** @member {string} */
		ON_CHAT_ROOM_READY:"onChatroomReady",
		/** @member {string} */
		ON_QUEUE_MESSAGE:"onQeueMsg",
		/** @member {string} */
		ON_ANY_EVENT:"onAnyEvent",
		/** @member {string} */
		ON_TRANSCRIPT_RCV_EVENT:"onTranscriptReceived",
		/** @member {string} */
		ON_FRAMEWORK_READY_EVENT:"onFrameworkReady"
	};

	/**
	 * @typedef {string} WindowPosition
	 **/

	/**
	* @property {WindowPosition} config.WindowPosition
	**/
	/**
	* @readonly
 	* @enum {WindowPosition}
	*/
	config.WindowPosition = {
		LOWER_RIGHT:"LOWER_RIGHT",
		LOWER_LEFT:"LOWER_LEFT",
		LOWER_CENTER:"LOWER_CENTER",
		UPPER_CENTER:"UPPER_CENTER",
		UPPER_LEFT:"UPPER_LEFT",
		UPPER_RIGHT:"UPPER_RIGHT",
		CENTER_LEFT:"CENTER_LEFT",
		CENTER_RIGHT:"CENTER_RIGHT",
		CENTER:"CENTER"

	};


	/*********************** Message Class *********************/

	function Message(command,info, brData) {
		this.command = command;
		this.info = info;
		this.brData = brData;
	}

	Message.prototype.toJSON = function() {
		return {
			"command":this.command,
			"info":this.info,
			"brData":this.brData
		};
	};

	Message.prototype.setCallback = function(cb, clear) {
		this.cb = cb;
		this.clear = typeof clear != "undefined" ? clear: true;
	};

	/*********************** End Message Class *********************/


	function iframeLoaded(frame){
		/**
		   Breaking out of this flow and adding to next event loop
		**/
		var that = this;
		var fTar = frame.target;
		currentFrame = frame;
		setTimeout(function(){
			frameCommHandler = new FrameCommunicationHandler(fTar);
			window.addEventListener("message",frameCommHandler.receiveMessage.bind(frameCommHandler));
			config.setPageData("InqRegistry",{"listeners":Object.keys(eventCBMap)});
			frameCommHandler.sendMessage(new Message("StartLoading",config.getUIConfig(),pageData));
			config.resetPageData();

			if(config.addBlockEnabled) {
				blockingDetector.onDetected(onDetectedFn).onNotDetected(onNotDetectedFn);
				blockingDetector.check(false);
			}
		},25);		
	}



	function testDomReady() {
		var WAIT_PERIOD = 100;
		if (typeof jQuery != "undefined" && jQuery.isReady) {
			setDomReadyTimeout(1);
		} else if (typeof doc.readyState == "undefined") {
			if (doc.addEventListener){
				doc.addEventListener("load",setDomReadyTimeout, false);
				doc.addEventListener("DOMContentLoaded", setDomReadyTimeout, false);
			}
			setDomReadyTimeout(WAIT_PERIOD);
		} else {

			var tridentVersion = navigator.userAgent.match(/Trident\/(\d+)/);
			var newIeVersion = tridentVersion && tridentVersion.length == 2 && parseInt(tridentVersion[1]) >= 6;
			if (doc.readyState=="complete" && newIeVersion) {
				setDomReadyTimeout();
	        } else if (!newIeVersion && doc.all && !window.opera){ 
	        	var script = doc.createElement("script");
				script.setAttribute("type", "text/javascript");
				script.setAttribute("id", "v3ContentLoadTag");
				script.setAttribute("defer", "defer");
				doc.body.appendChild(script);

				var v3ContentLoadTag=doc.getElementById("v3ContentLoadTag");
				if (v3ContentLoadTag){
					v3ContentLoadTag.onreadystatechange=function(){
						if (this.readyState=="complete"){
							setDomReadyTimeout(WAIT_PERIOD);
						}
					};
				}
				else {
					if (doc.readyState == "complete") {
						setDomReadyTimeout(1);
					}
					else {
						doc.attachEvent("onreadystatechange", function(){
							if (doc.readyState === "complete") {
								doc.detachEvent("onreadystatechange", arguments.callee);
								setDomReadyTimeout(1);
							}
						});
					}
				}
	        } else if (doc.addEventListener || (newIeVersion && doc.attachEvent)){
				if (/loaded|complete/.test(doc.readyState)) {
					setDomReadyTimeout();
				} else {
					setTimeout(arguments.callee,100);
				}
			}
	     	
	    }
	}


	function fireMesageToBridge(msg){
		if(frameCommHandler) {
			frameCommHandler.sendMessage(msg);
		}
	}



	/*********** IFrame creation code ***********************/
	function setDomReadyTimeout(t) {
		setTimeout(function(){
			var frameSrc = (config.tagServerUrl+config.chatLaunchFileAndPath)+"?UUID="+urlConfigObj.vendorUUID;
			var div = doc.createElement("div") ;
			div.id = frameID;
			div.classList.add("floating-nuan-chat");
			div.style.cssText = "z-index:9999999;height:1px;width:1px;" +
								"border-style: none;border-width: 0px;"; 
			var htmls = ['<iframe title="Chat Window"'];
			htmls.push(' name="'+config.siteID+'"');	
			htmls.push(' src="' + frameSrc + '"');
			htmls.push(' aria-hidden=true');
			htmls.push(' hidden=true');
			//if(!disableC2Crender) {
				//htmls.push(' class="floating-nuan-chat"');			
			//}
			htmls.push(' scrolling="NO"');
			htmls.push(' frameborder=0');
			htmls.push('></iframe>');
			div.innerHTML = htmls.join("");

			var bdy=doc.body;
			if (bdy){
				var iframe = div.getElementsByTagName("IFRAME")[0] ;
				iframe.setAttribute('sandbox', 'allow-same-origin allow-scripts allow-popups allow-modals');
				iframe.onload = iframeLoaded;
				//if(!disableC2Crender) {
					//bdy.appendChild(iframe);
				//} else {
					bdy.appendChild(div);
					if(bootstrapC2cInstance) { 
						bootstrapC2cInstance.setParentElement(div);
					}
				//}

								
			}

			

		}, t || 25);
	}



	function onDetectedFn(){
		fireMesageToBridge(new Message("AD_BLOCKER_DETECTED"));
	}

	function onNotDetectedFn(){
		log("ad blocker not detected");
	}

	/**
	 Area utility class to keep track of chat frame position
	 @constructor
	*/

	function Area(x, y, width, height){
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	}

	Area.prototype.setBRPosition = function(right, bottom, width, height) {
		this.r = right;
		this.b = bottom;
		this.width = width;
		this.height = height;
	};

	Area.prototype.isXYAxisPos = function() {
		return this.x >= 0 && this.y >= 0;
	};

	Area.prototype.toJSON = function() {
		return {
			"x":this.x,
			"y":this.y,
			"r":this.r,
			"b":this.b,
			"width":this.width,
			"height":this.height
		};
	};

	function Point(p1, p2){
		this.p1 = p1;
		this.p2 = p2;
	}

	/**
	 Utility class to manage creation of element and inserting to dom
	 @constructor
	*/

	function Element(id) {
		this.div = document.createElement("DIV");
		this.div.id = id;
	}
	Element.prototype.addCssText = function(text) {
		this.div.style = text;
	};
	Element.prototype.setStyle = function(style, value){
		this.div.style[style] = value;
	};
	Element.prototype.setInnerHTML = function(html){
		this.div.innerHTML = html;
	};
	Element.prototype.appendToParent = function(parent) {
		
		parent.appendChild(this.div);
	};
	Element.prototype.setAttribute = function(attr, value) {
		this.div.setAttribute(attr, value);
	};
	Element.prototype.delete = function() {
		this.div.parentElement.removeChild(this.div);
	};



	/**
	 Active Window logic is to detect if client page is opened in more than one tab and to detect the active tab amoung them
	 @constructor
	*/

	function ActiveWindow() {
		top.window.addEventListener("focus", this.setWindowActive);
	    top.window.document.addEventListener("visibilitychange", this.setWindowActive);
	}

	ActiveWindow.prototype.setWindowActive = function() {
		if(!window.top.document.hidden) {
			fireMesageToBridge(new Message("ACTIVE_WINDOW"));
		}
	};

	ActiveWindow.prototype.removeListener = function() {
		top.window.removeEventListener("focus", this.setWindowActive);
	    top.window.document.removeEventListener("visibilitychange", this.setWindowActive);
	};

	
function debounce(func, wait, immediate) {
	var timeout;

	return function executedFunction() {
	var context = this;
	var args = arguments;
	    
	var later = function() {
	  timeout = null;
	  if (!immediate) func.apply(context, args);
	};

	var callNow = immediate && !timeout;

	clearTimeout(timeout);

	timeout = setTimeout(later, wait);

	if (callNow) func.apply(context, args);
	};
}

function checkArity(objParam, type) {
	var obj;
	switch(type){
		case "config":
			obj = urlConfigKeys;
		break;
	}

	if(obj) {
		return obj.every(function(key){
			if(!objParam[key]) {
				return false;
			}
		});
	}
}

function log(msg) {
	if(mode == 0) {
		console.log("Messaging-WebSDK:"+msg);
	}
}

function isNullOrUndefined(val) {
	return val == null || typeof(val) == "undefined";
}

function attachListener(target, type, listener, useCapture) {
	if (!useCapture) {
		// Prior to Firefox 6, the browser would throw an error
		// if the useCapture parameter was not explicitly false.
		useCapture = false;
	}
	if (target.addEventListener) {
		target.addEventListener(type, listener, useCapture);
	} else if (target.attachEvent) {
		target.attachEvent("on" + type, listener);
	}
}

function attachAndSaveListener(target, type, listener, useCapture) {
	attachListener(target, type, listener, useCapture);

	domListeners.push({
	target: target,
		type: type,
		listener: listener
	});
}

function detachListener(target, type, listener, useCapture) {
	if (!useCapture) {
		// Prior to Firefox 6, the browser would throw an error
		// if the useCapture parameter was not explicitly false.
		useCapture = false;
	}
	if (target.removeEventListener) {
		target.removeEventListener(type, listener, useCapture);
	} else if (target.attachEvent) {
		target.detachEvent("on" + type, listener);
	}
}


function executeFunction(name, params) {
	var funcRef;
	if(funcMap[name]) {
		funcRef = funcMap[name];
	} else if(window[name]) {
		funcRef = window[name];
	}

	if(funcRef) {
		return funcRef.apply(null,params);
	} else if (name.indexOf(".") != -1) {
		var t = name.split("."), k;
		for (var i = 0; i < t.length; i++) {
			if (typeof k != "undefined") {
				if (typeof k[t[i]] == "function") {
					(k[t[i]]).apply(parent, params);
				} else if (typeof k[t[i]] == "object") {
					k = k[t[i]];
				}
			} else {
				if (typeof parent[t[i]] == "function") {
					(parent[t[i]]).apply(parent, [cmdParam]);
				} else if (typeof parent[t[i]] == "object") {
					k = parent[t[i]];
				}
			}
		}	
	}

}

function isIOS() {
	return /(iPad|iPhone|iPod)/g.test( window.navigator.userAgent );
}

function isPhone(){
	return deviceType == "Phone";
}

function isTablet(){
	return deviceType == "Tablet";
}

function isMobile() {
	return isPhone() || isTablet();
}

function isIpad() {
	return isTablet() && isIOS();
}

function getOSType() {
	var os = "Unknown";
	var platform = window.navigator.platform;
	var ua = window.navigator.userAgent;

	if (/Android/.test(ua)) {
		os = "Android";
	} else if (/iPhone/.test(ua) || /iPad/.test(ua) || /iPod/.test(ua)) {
		os = "iOS";
	} else if (/Win/.test(platform)) {
		os = "Windows";
	} else if (/Linux/.test(platform)) {
		os = "Linux";
	} else if (/Mac/.test(platform)) {
		os = "Mac OS";
	} 

	return os;
}

function isAndroidWebView() {
	var pattern = new RegExp("Android.*?(wv|Version\\/[.0-9]+).*?Chrome\\/[0-9]{2}", "i");
	return pattern.test(window.navigator.userAgent);
}

function isChrome() {
	return (window.navigator.userAgent.indexOf("Chrome") >= 0 || window.navigator.userAgent.indexOf("CriOS") >= 0) && (!isAndroidWebView()); // navigator.userAgent for Edge have "Chrome" inside the value
}

function isIE() {
	return window.navigator.appName == "Microsoft Internet Explorer" || window.navigator.userAgent.indexOf("Trident") != -1;
}

function isElementInViewport (el) {
	if(!el) return false;

	var rect = el.getBoundingClientRect();
	var vpHeight = window.top.innerHeight;
	var vpWidth = window.top.innerWidth;
    return rect.top >= 0 &&
		rect.left >= 0 &&
		rect.bottom <= vpHeight &&
		rect.right <= vpWidth;
}

function getIphoneModel() {
	var canvas = document.createElement("canvas"); // Create a canvas element which can be used to retrieve information about the GPU.
	var renderer = "";
	if (canvas) {
		var context = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
		if (context) {
			var info = context.getExtension("WEBGL_debug_renderer_info");
			if (info) {
				renderer = context.getParameter(info.UNMASKED_RENDERER_WEBGL);
			}
		}
	}

	if (window.parent.screen.height / window.parent.screen.width == 896 / 414 && window.devicePixelRatio == 3) {
		switch (renderer) {
			case "Apple A12 GPU":
				result = "iPhoneXSMax";
				break;
			default:
				result = "iPhoneXSMax";
		}
	} else if (window.parent.screen.height / window.parent.screen.width == 896 / 414 && window.devicePixelRatio == 2) {
		switch (renderer) {
			case "Apple A12 GPU":
				result = "iPhoneXR";
				break;
			default:
				result = "iPhoneXR";
		}
	} else if (window.parent.screen.height / window.parent.screen.width == 812 / 375 && window.devicePixelRatio == 3) {
		switch (renderer) {
			case "Apple A12 GPU":
				result = "iPhoneXS_XSMaxZoomed";
				break;
			case "Apple A11 GPU":
				result = "iPhoneX";
				break;
			default:
				result = "iPhoneX";
		}
	} else if (window.parent.screen.height / window.parent.screen.width == 812 / 375 && window.devicePixelRatio == 2) {
		switch (renderer) {
			case "Apple A12 GPU":
				result = "iPhoneXRZoomed";
				break;
			default:
				result = "iPhoneXRZoomed";
		}
	} else if ((window.parent.screen.height / window.parent.screen.width == 736 / 414) && (window.devicePixelRatio == 3)) { // iPhone 6+/6s+/7+ and 8+
		switch (renderer) {
			case "Apple A8 GPU":
				result = "iPhone6Plus";
				break;
			case "Apple A9 GPU":
				result = "iPhone6sPlus";
				break;
			case "Apple A10 GPU":
				result = "iPhone7Plus";
				break;
			case "Apple A11 GPU":
				result = "iPhone8Plus";
				break;
			default:
				result = "iPhone6Plus";
		}
	} else if ((window.parent.screen.height / window.parent.screen.width == 667 / 375) && (window.devicePixelRatio == 3)) { // iPhone 6+/6s+/7+ and 8+ in zoom mode
		switch(renderer) {
			case "Apple A8 GPU":
				result = "iPhone6PlusZoomed";
				break;
			case "Apple A9 GPU":
				result = "iPhone6sPlusZoomed";
				break;
			case "Apple A10 GPU":
				result = "iPhone7PlusZoomed";
				break;
			case "Apple A11 GPU":
				result = "iPhone8PlusZoomed";
				break;
			default:
				result = "iPhone6PlusZoomed";
		}
	} else if ((window.parent.screen.height / window.parent.screen.width == 667 / 375) && (window.devicePixelRatio == 2)) { // iPhone 6/6s/7 and 8
		switch(renderer) {
			case "Apple A8 GPU":
				result = "iPhone6";
				break;
			case "Apple A9 GPU":
				result = "iPhone6s";
				break;
			case "Apple A10 GPU":
				result = "iPhone7";
				break;
			case "Apple A11 GPU":
				result = "iPhone8";
				break;
			default:
				result = "iPhone6";
		}
	} else if ((window.parent.screen.height / window.parent.screen.width == 1.775) && (window.devicePixelRatio == 2)) { // iPhone 5/5C/5s/SE or 6/6s/7 and 8 in zoom mode
		switch(renderer) {
			case "PowerVR SGX 543":
				result = "iPhone5";
				break;
			case "Apple A7 GPU":
				result = "iPhone5s";
				break;
			case "Apple A8 GPU":
				result = "iPhone6Zoomed";
				break;
			case "Apple A9 GPU":
				result = "iPhone6sZoomed";
				break;
			case "Apple A10 GPU":
				result = "iPhone7Zoomed";
				break;
			case "Apple A11 GPU":
				result = "iPhone8Zoomed";
				break;
			default:
				result = "iPhone6Zoomed";
		}
	} else {
		result = "Not an iPhone";
	}

	return result;
}

function getVisualViewportHeight() {
	if (visualViewport) {
		var scaledHeight = visualViewport.height * visualViewport.scale;
		return Math.round(scaledHeight);
	}
	return 0;
}


    
	var BlockingDetector = function(options) {
		this._options = {
			checkOnLoad:		false,
			resetOnEnd:			false,
			loopCheckTime:		1000,
			loopMaxNumber:		3600,
			baitClass:			'pub_300x250 pub_300x250m pub_728x90 text-ad textAd text_ad text_ads text-ads text-ad-links',
			baitStyle:			'width: 1px !important; height: 1px !important; position: absolute !important; left: -10000px !important; top: -1000px !important;',
			debug:				false
		};
		this._var = {
			version:			'3.2.1',
			bait:				null,
			checking:			false,
			loop:				null,
			loopNumber:			0,
			event:				{ detected: [], notDetected: [] }
		};
		if(options !== undefined) {
			this.setOption(options);
		}
		var self = this;
		var eventCallback = function() {
			setTimeout(function() {
				if(self._options.checkOnLoad === true) {
					if(self._options.debug === true) {
						self._log('onload->eventCallback', 'A check loading is launched');
					}
					if(self._var.bait === null) {
						self._createBait();
					}
					setTimeout(function() {
						self.check();
					}, 1);
				}
			}, 1);
		};
		if(window.addEventListener !== undefined) {
			window.addEventListener('load', eventCallback, false);
		} else {
			window.attachEvent('onload', eventCallback);
		}
	};

	BlockingDetector.prototype._options = null;
	BlockingDetector.prototype._var = null;
	BlockingDetector.prototype._bait = null;

	BlockingDetector.prototype._log = function(method, message) {
		log('[BlockingDetector][' + method + '] ' + message);
	};

	BlockingDetector.prototype.setOption = function(options, value) {
		if(value !== undefined) {
			var key = options;
			options = {};
			options[key] = value;
		}
		for(var option in options) {
			this._options[option] = options[option];
			if(this._options.debug === true) {
				this._log('setOption', 'The option "' + option + '" he was assigned to "' + options[option] + '"');
			}
		}
		return this;
	};

	BlockingDetector.prototype._createBait = function() {
		var bait = document.createElement('div');
		bait.setAttribute('class', this._options.baitClass);
		bait.setAttribute('style', this._options.baitStyle);
		this._var.bait = window.document.body.appendChild(bait);

		/*this._var.bait.offsetParent;
		this._var.bait.offsetHeight;
		this._var.bait.offsetLeft;
		this._var.bait.offsetTop;
		this._var.bait.offsetWidth;
		this._var.bait.clientHeight;
		this._var.bait.clientWidth;
		*/

		if(this._options.debug === true) {
			this._log('_createBait', 'Bait has been created');
		}
	};
	BlockingDetector.prototype._destroyBait = function() {
		window.document.body.removeChild(this._var.bait);
		this._var.bait = null;

		if(this._options.debug === true) {
			this._log('_destroyBait', 'Bait has been removed');
		}
	};

	BlockingDetector.prototype.check = function(loop) {
		if(loop === undefined) {
			loop = true;
		}

		if(this._options.debug === true) {
			this._log('check', 'An audit was requested ' + (loop===true?'with a':'without') + ' loop');
		}

		if(this._var.checking === true) {
			if(this._options.debug === true) {
				this._log('check', 'A check was canceled because there is already an ongoing');
			}
			return false;
		}
		this._var.checking = true;

		if(this._var.bait === null) {
			this._createBait();
		}

		var self = this;
		this._var.loopNumber = 0;
		if(loop === true) {
			this._var.loop = setInterval(function() {
				self._checkBait(loop);
			}, this._options.loopCheckTime);
		}
		setTimeout(function() {
			self._checkBait(loop);
		}, 1);
		if(this._options.debug === true) {
			this._log('check', 'A check is in progress ...');
		}

		return true;
	};
	BlockingDetector.prototype._checkBait = function(loop) {
		var detected = false;

		if(this._var.bait === null) {
			this._createBait();
		}

		if(window.document.body.getAttribute('abp') !== null || this._var.bait.offsetParent === null || this._var.bait.offsetHeight == 0 || this._var.bait.offsetLeft == 0 || this._var.bait.offsetTop == 0 || this._var.bait.offsetWidth == 0 || this._var.bait.clientHeight == 0 || this._var.bait.clientWidth == 0) {
			detected = true;
		}
		if(window.getComputedStyle !== undefined) {
			var baitTemp = window.getComputedStyle(this._var.bait, null);
			if(baitTemp && (baitTemp.getPropertyValue('display') == 'none' || baitTemp.getPropertyValue('visibility') == 'hidden')) {
				detected = true;
			}
		}

		if(this._options.debug === true) {
			this._log('_checkBait', 'A check (' + (this._var.loopNumber + 1) + '/' + this._options.loopMaxNumber + ' ~' + (1 + this._var.loopNumber*this._options.loopCheckTime) + 'ms) was conducted and detection is ' + (detected===true?'positive':'negative'));
		}

		if(loop === true) {
			this._var.loopNumber++;
			if(this._var.loopNumber >= this._options.loopMaxNumber) {
				this._stopLoop();
			}
		}

		if(detected === true) {
			this._stopLoop();
			this._destroyBait();
			this.emitEvent(true);
			if(loop === true) {
				this._var.checking = false;
			}
		} else if(this._var.loop === null || loop === false) {
			this._destroyBait();
			this.emitEvent(false);
			if(loop === true) {
				this._var.checking = false;
			}
		}
	};
	BlockingDetector.prototype._stopLoop = function(detected) {
		clearInterval(this._var.loop);
		this._var.loop = null;
		this._var.loopNumber = 0;

		if(this._options.debug === true) {
			this._log('_stopLoop', 'A loop has been stopped');
		}
	};

	BlockingDetector.prototype.emitEvent = function(detected) {
		if(this._options.debug === true) {
			this._log('emitEvent', 'An event with a ' + (detected===true?'positive':'negative') + ' detection was called');
		}

		var fns = this._var.event[(detected===true?'detected':'notDetected')];
		for(var i in fns) {
			if(this._options.debug === true) {
				this._log('emitEvent', 'Call function ' + (parseInt(i) + 1) + '/' + fns.length);
			}
			if(fns.hasOwnProperty(i)) {
				fns[i]();
			}
		}
		if(this._options.resetOnEnd === true) {
			this.clearEvent();
		}
		return this;
	};
	BlockingDetector.prototype.clearEvent = function() {
		this._var.event.detected = [];
		this._var.event.notDetected = [];

		if(this._options.debug === true) {
			this._log('clearEvent', 'The event list has been cleared');
		}
	};

	BlockingDetector.prototype.on = function(detected, fn) {
		this._var.event[(detected===true?'detected':'notDetected')].push(fn);
		if(this._options.debug === true) {
			this._log('on', 'A type of event "' + (detected===true?'detected':'notDetected') + '" was added');
		}

		return this;
	};
	BlockingDetector.prototype.onDetected = function(fn) {
		return this.on(true, fn);
	};
	BlockingDetector.prototype.onNotDetected = function(fn) {
		return this.on(false, fn);
	};

	if(blockingDetector === undefined) {
		blockingDetector = new BlockingDetector({
			checkOnLoad: true,
			resetOnEnd: true
		});
	}    
    /**
* FrameCommunicationHandler class handlers the communication between bootstrap and Sandboxed iframe. 
*/
function FrameCommunicationHandler(frameElement) {
	this.frameEl = frameElement;
	 

}

/**
* postmessage from sandboxed iframe is received and process it
*/
FrameCommunicationHandler.prototype.receiveMessage = function(e){
	if(msgWatchCB) {
		msgWatchCB("RECEIVED",e.data);
	}
	var dataObj;
	try {
	   dataObj = JSON.parse(e.data);
	} catch (exception) {
		log("failed to parse json");
	}
	if(this.verifyMessage(dataObj)) {

		switch(dataObj.command) {
			case "CHAT_EVENT":
			/**
			* events from sandboxed iframe is passed to the registered callback
			*/
			if(eventCBMap && eventCBMap[dataObj.info.name]) {
				eventCBMap[dataObj.info.name].forEach(function(cb){
					cb(dataObj.info.data);
				});
			}

			break;

			case "CALL_OUT_FUNC":
			/**
			* some time nuance targetting needs to execute javascript function in the parent window, 
			* if available in the window it will be called here
			*/
				var name = dataObj.info.name;
				var params = dataObj.info.params;
				executeFunction(name, params);

			break;

			case "PERSISTENT_URL_ACTION":
			/**
			* since sandboxed iframe cannot create a popup window , launching persistent chat is handled here
			*/
				var c2cInstance;
				c2cmgr.c2cs.forEach(function(c2c){
					if(c2c.c2cData.c2cIdx == dataObj.info.c2cIdx) {
						c2cInstance = c2c;							
					}
				});
				var fObj = C2CMgr.getPersistentWindow(c2cInstance);
				if(fObj) {
					fObj.close();
					fObj = null;
				}
				if(!fObj) {

					if(!C2CMgr.earlyPopout || C2CMgr.earlyPopout.closed) {
						C2CMgr.earlyPopoutChat(dataObj.info.theme);
					}
					if(C2CMgr.earlyPopout) {
						try {
							C2CMgr.earlyPopout.location.href = config.tagServerUrl+dataObj.info.src + "?UUID="+config.vendorUUID+"&siteID="+config.siteID;
							c2cInstance.popoutWindow = C2CMgr.earlyPopout;
							C2CMgr.earlyPopout = null;
						} catch(exception) {
							C2CMgr.earlyPopout = null;
						}
					}
				}
			break;
			case "PERSISTENT_WINDOW_CLOSE":
			/**
			* closing the popup window
			*/
				if(C2CMgr.earlyPopout) {
					C2CMgr.earlyPopout.close();
					C2CMgr.earlyPopout = null;
				} else {
					c2cmgr.c2cs.forEach(function(c2c){
						if(c2c.popoutWindow) {
							c2c.popoutWindow.close();
						} 
					});
				}
			break;

			case "EXECUTE_AND_RETURN_FUNC":
			/**
			* some time nuance targetting needs to execute javascript function and needs the return value, 
			* if available in the window it will be called here and return the result
			*/
				var fname = dataObj.info.name;
				var fparams = dataObj.info.params;
				var result = executeFunction(fname, fparams);
				if(result) {
					var fpageData = {};
					fpageData[fname] = result;
					NuanMessaging.SDKAPI.publishNewPageData(fpageData);
				}
			break;

			case "FETCH_PAGE_DATA":
			/**
			* some time nuance targetting needs page data, for ex: a.b.c, 
			* if available in the window it will be found here the send the results back
			*/
				var vitems = dataObj.info || [];

				if(vitems.length > 0) {
					var vpageData = {};
					vitems.forEach(function(item){

						var osa = String(item).split(".");
                        var winObj = window;
                        var resDataObj = vpageData;
                        osa.every(function(token, index){
                           
                            if (index === (osa.length - 1)) {
                            	if(winObj[token]) {
                                    resDataObj[token] = winObj[token];
                                }
                                return true;
                            }

                            winObj = winObj[token];

                            if(!winObj){
                            	return false;
                            }
                            resDataObj = resDataObj[token] = {};
                            return true;

                        });


					});
					if(Object.keys(vpageData).length>0) {
						NuanMessaging.SDKAPI.publishNewPageData(vpageData);
					}
				}

				
			break;

			case "FETCH_DOM_DATA":
			/**
			* some time nuance targetting needs dom data, 
			* if available in the window it will be found here the send the results back
			*/
				var ditems = dataObj.info || [];

				if(ditems.length > 0) {
					var dpageData = {};
					ditems.forEach(function(item){
						var el = document.querySelector(item);
						if(el) {
							var val = el.value? el.value: (el.textContent?el.textContent:el.innerText);
							if(val) {
								dpageData[item] = val;
							}
						}
					});
					if(Object.keys(dpageData).length>0) {
						NuanMessaging.SDKAPI.publishNewPageData(dpageData);
					}
				}
			break;

			case "REGISTER_DOM_EVENT":
			/**
			* some time nuance targetting needs dom events, 
			* if available in the dom then it is queried here and registers an event listener
			*/
				if(dataObj.info.eventData){
					var elArray = [];
					var eData = dataObj.info.eventData;
					var domEls = eData.domElements;
					if(eData.domElementId) {
						 var el1 = document.getElementById(eData.domElementId);
        				 if (!!el1) elArray[0] = el1;

					}
					domEls.forEach(function(domel){
					if(domel.elementId) {
						var el = document.getElementById(domel.elementId);
        				if (!!el) elArray[0] = el;

					} else if(domel.className) {
						elArray.push(document.getElementsByClassName(domel.className));
					} else if(domel.elementName) {
						elArray.append(document.getElementsByName(domel.elementName));
					} else if(domel.tagName) {
						elArray.push(document.getElementsByTagName(domel.tagName));
					} else if(domel.funcName) {
						var result = executeFunction(domel.funcName);
						if(result && Array.isArray(result)){
							elArray.push(result);
						}
					}	
					});
					 

					 if(elArray.length > 0) {
					 	var startHover;
					 	var _mouseOver = function (evt) {
                        	var hoverTime = eData.hoverTime ? eData.hoverTime : 15000;
                    		startHover = window.setTimeout(function(){
                    			fireMesageToBridge(new Message("EVENT_GENERATED",{ruleId:dataObj.info.ruleId,evtObj:evt,evtData:eData})); 
                    		}, hoverTime);	
                        };

                        var _mouseOut = function (evt) {
                            window.clearTimeout(startHover);
                        };

                        var _otherHandler = function (evt) {
                           fireMesageToBridge(new Message("EVENT_GENERATED",{ruleId:dataObj.info.ruleId,evtObj:evt,evtData:eData})); 
                        };

					 	for (var i = 0; i < elArray.length; i++) {
                			var el = elArray[i];
                			if(el) {
                    			if(eData.id == "mouseover"){
	                                attachAndSaveListener(
	                                    el,
	                                    "mouseover",
	                                    _mouseOver
	                                );
	                                attachAndSaveListener(
	                                    el,
	                                    "mouseout",
	                                    _mouseOut
	                                );

	                            } else {
	                                attachAndSaveListener(
	                                    el,
	                                    eData.id,
	                                    _otherHandler
	                                );
	                            }

                        	}
                    		

                		}
					 }

				}

			break;

			case "POSITION_IFRAME":
			/**
			* event to handle chat window placement and position
			*/
				deviceType = dataObj.info.deviceType;
				if(!messageWindow) {
					messageWindow = new MessageWindow();
				}
				messageWindow.render(dataObj.info);	
				

			break;

			case "MINIMIZE_WINDOW":
			/**
			* event to handle chat window minimized state, so that iframe can be hidden from customer 
			*/
				if(messageWindow) {
					messageWindow.minimize();
				}
				if(c2cmgr) {
					c2cmgr.renderState(c2cmgr.IMAGETYPES.minimized,{launchable:true});
				}

			break;

			case "DEEPLINK_COMMAND": {
			/**
			* event to handle top window navigation also deep link's that client javascript is intereseted to handle 
			*/
				var _url = dataObj.info.url;
				var _target = dataObj.info.target;
				if(_url && _url.startsWith("http") && _target) {
					if ("_self" == _target) {
						top.document.location.href = _url;
					} else{
						var winTarget = null ;
						winTarget = window.top.open(_url, _target, "top=0;left=0");
						if (null == winTarget) {
							winTarget = window.top.open(_url, _target);
						}
					}	
				}
			}
			break;

			case "NEW_MSG_ON_MINIMIZED":
				minimizedCount+=1;
				c2cmgr.messageOnMinimized(dataObj.info);
			break;

			case "VIRTUAL_KEYBOARD_OPEN":{
				if(messageWindow) {
					messageWindow.virtualKeyboardDisplayed();
				}
			}
			break;

			case "VIRTUAL_KEYBOARD_HIDDEN": {
				if(messageWindow) {
					messageWindow.virtualKeyboardHidden();
				}
			}
			break;

			default: {
				this.fireCallbackQueue(dynamicCBQueue,dataObj);
			}
		}
		e.stopImmediatePropagation();
	} else {
		log("Failed to verify the UUID");
	}


};

/**
* invokes the callbacks registered with various message type send from sandboxed iframe
*/
FrameCommunicationHandler.prototype.fireCallbackQueue = function(callbackQueue,dataObj) {
	var objIndex = -1;
	callbackQueue.every(function(msgObj, index){
		if(msgObj.command == dataObj.command) {
			if(msgObj.cb) {
				msgObj.cb(dataObj.info);
			}
			if(msgObj.clear) {
				objIndex = index;
			}
			return false;
		}
		return true;
	});

	if(objIndex != -1) {
		callbackQueue.splice(objIndex,1);
	}
};

FrameCommunicationHandler.prototype.sendMessage = function(msg){
	if(msgWatchCB) {
		msgWatchCB("POST",msg);
	}
	this.frameEl.contentWindow.postMessage(JSON.stringify(msg),config.tagServerUrl);
};


FrameCommunicationHandler.prototype.verifyMessage = function(msgObj){
	if(msgObj && msgObj.UUID == urlConfigObj.vendorUUID) {
		return true;
	}
	return false;
};


    
	/**
	* Nuance out of the box c2c rendering solution , c2c theme which is configured in nuance portal is used here to render the different
	* states if c2c button.
	* Clients can turn off out of the box c2c solution and can use C2C plugins available with the bootstrap package
	* @see nuan-c2c.js plugin code
	*/

	function C2CMgr() {
		this.c2cs = [];
	}
	C2CMgr.lastusedC2CId = null;
	C2CMgr.c2cBtnId = null;
	C2CMgr.prototype.render = function(c2cData) {
		if(minimized ||(c2cData.minimized && c2cData.minimized.state)) {
			c2cData.image = this.IMAGETYPES.minimized;
			c2cData.count = (c2cData.minimized && c2cData.minimized.count) ? c2cData.minimized.count : minimizedCount;
			c2cData.launchable = true;
		}
		var c2c;
		if(!disableC2Crender || c2cData.c2cTheme && c2cData.c2cTheme.renderAsHTML) {
			if((minimized  || (c2cData.minimized && c2cData.minimized.state)) && bootstrapC2cInstance) {
				if (!bootstrapC2cInstance.isDisplayed()) {
					bootstrapC2cInstance.renderC2CButton(c2cData);
				}
			} else {
				c2c = new C2C(c2cData);
				if(c2c.renderC2CButton(c2cData)){
					this.c2cs.push(c2c);
				}
			}
		} else {
			if(bootstrapC2cInstance && !bootstrapC2cInstance.isDisplayed()) {
				c2c = bootstrapC2cInstance;
				bootstrapC2cInstance.renderC2CButton(c2cData);
				this.c2cs.push(bootstrapC2cInstance);
			}
		} 

		if(c2cData.isPersistentChat && c2cData.displayState == "chatactive") {
			c2c.popoutWindow = 	C2CMgr.getPersistentWindow(c2c, "chatactive");
		}

	};

	C2CMgr.prototype.messageOnMinimized = function(msgObject) {
		if(!disableC2Crender && bootstrapC2cInstance && bootstrapC2cInstance.isDisplayed()) {
			bootstrapC2cInstance.newMinimizedMessage(minimizedCount,msgObject);
		} else {
			this.c2cs.forEach(function(c2c){
				c2c.newMinimizedMessage(minimizedCount,msgObject);
			});
		}
		
	};

	C2CMgr.prototype.clear = function() {
		this.c2cs.forEach(function(c2c){
			c2c.clearListeners();
			c2c.clear();			
		});
		this.c2cs = [];
		C2CMgr.earlyPopout = null;
		minimizedCount = 0;
		minimized  = false;
	};

	C2CMgr.prototype.setDisabled = function(data){
		this.c2cs.forEach(function(c2c){
			c2c.showDisabled();
		});

		if(!disableC2Crender && bootstrapC2cInstance && bootstrapC2cInstance.isDisplayed()) {
			bootstrapC2cInstance.clearListeners();
			bootstrapC2cInstance.clear();
		}
	};

	C2CMgr.prototype.renderState = function(image, data){
		if(disableC2Crender || bootstrapC2cInstance) {
			
			if(bootstrapC2cInstance && bootstrapC2cInstance.isDisplayed() && image != this.IMAGETYPES.chatactive) {
				bootstrapC2cInstance.renderState(image, data);
			} else if(image == this.IMAGETYPES.minimized && !disableC2Crender) {
				data.image = this.IMAGETYPES.minimized;
				bootstrapC2cInstance.renderC2CButton(data);
			}
		} else {
			this.c2cs.forEach(function(c2c){
				if(c2c.c2cData.c2cIdx == data.c2cIdx) {
					c2c.showIcon(image,data.launchable, c2c.c2cData, c2c.div , data.chatVisible);
				}
			});
		}
		
	};

	C2CMgr.prototype.c2cCallbackHandler = function(cb,c2cState){
		if(!disableC2Crender && c2cState && c2cState.state == "disabled") {
			this.setDisabled();
		} else {
			if (cb) {
				cb(c2cState);
			}
		}
	};

	C2CMgr.prototype.IMAGETYPES = {disabled: "d", chatactive:"d", busy: "b", afterHours: "ah", ready: "r", minimized: "m"};


     //can comment from here if out of the box c2c solution is not used
	function C2C(c2cData) {
		this.c2cData = c2cData;
		this.listeners = [];
	}

	C2C.prototype.renderC2CButton = function(c2cData) {
		var eDiv = this.getDiv(c2cData.pageElementID);
		var div = this.div = eDiv;
		if(!this.isDivOccupied(eDiv)) {
			if(div != null && typeof c2cData.lang != "undefined") {
				eDiv.setAttribute("lang", c2cData.lang);
			}

			// CATO support.
			if(c2cData.adaCompliant) {
				eDiv.setAttribute("aria-live","polite");
			}

			eDiv.occupied = true;
			eDiv.idx=c2cData.c2cIdx;

			if(!!c2cData.abs){
				eDiv.style.position = "absolute";
				eDiv.style.top = c2cData.abs.y;
				eDiv.style.left = c2cData.abs.x;
			}

			this.showIcon(c2cData.image,c2cData.launchable, c2cData, eDiv , false);
			return true;
		}

		return false;

	};

	C2C.prototype.showIcon = function (name, clickable,c2cData ,eDiv, chatActive) {
		if (c2cData.c2cTheme.renderAsHTML) {
				this.showTextButton(name, clickable, c2cData,eDiv);
			} else {
				this.showImg(name, clickable,c2cData ,eDiv,chatActive);
			}
			// Fix the C2C location if is it not visible.
			this.fixC2CLocation(eDiv);

			this.updateContainerStyle(eDiv);
	};

	C2C.prototype.showTextButton = function (name, clickable, c2cData,eDiv) {
		var c2cTheme = c2cData.c2cTheme[name];
		eDiv.innerHTML = '<div ' + (isIOS()?' tabindex="0"':'')+'>' + c2cTheme + '</div>';
		if (clickable) {
			this.addEventHandlers(eDiv, c2cData.c2cIdx, 'onclick', c2cData, name);
		}
	};

	C2C.prototype.newMinimizedMessage = function(count){

	};

	C2C.prototype.showImg = function(img, clickable,c2cData ,eDiv,chatActive){
		var altText = c2cData.c2cTheme[img + 'alt'];
		if(typeof altText === 'undefined' || altText == null || altText === "") {
			altText = "Click To Chat";
		}
		
		var eventName = isIOS() ? "ontouchstart" : 'onclick' ;
		
		var onclicktxt = clickable ? ' alt=\"' + altText + '\" tabindex="0"' : 'alt=\"' + altText + '\"';

		 if((c2cData.c2p || c2cData.adaCompliant) && clickable){
			eDiv.innerHTML='<input type="image" role="button" src=\"'+ c2cData.mediaURL + '/images/' + c2cData.c2cTheme[img] + '\"' + onclicktxt + (c2cData.adaCompliant?' style="cursor:default" ':'')+'/>';
			
			if (clickable) {
				this.addEventHandlers(eDiv, c2cData.c2cIdx, eventName,c2cData,img);
			}
			
		}
		else{
			eDiv.innerHTML='<img src=\"'+ c2cData.mediaURL + '/images/' + c2cData.c2cTheme[img] + '\"' + onclicktxt + ' style="cursor:default" '+(chatActive?'aria-hidden="true" tabindex="-1"':'')+'/>';
			if (clickable) {
				this.addEventHandlers(eDiv, c2cData.c2cIdx, eventName,c2cData, img);
			}
			
		}

		if (c2cData.reDisplay === true && ((!C2CMgr.lastusedC2CId && C2CMgr.c2cBtnId==null && eDiv.idx === 0) || (!C2CMgr.lastusedC2CId && C2CMgr.c2cBtnId!=null && C2CMgr.c2cBtnId == eDiv.idx) || (C2CMgr.lastusedC2CId && C2CMgr.lastusedC2CId === eDiv.id))) {
					var c2cDiv = document.getElementById(eDiv.id);
					
					var ignoreScrolling = c2cData.ignorePageScrollingOnC2CFocus ? true : false;
					/* On Desktop if C2C is not fixed then it should be visible to set focus on it to prevent page scroll */
					if (c2cData.deviceType == "Phone" || c2cData.deviceType == "Tablet" || ((c2cDiv.style.position === 'fixed' || ignoreScrolling || isElementInViewport(c2cDiv)))){
						window.setTimeout(function () {
							if (c2cDiv && c2cDiv.firstChild) {
								var c2cChild = C2C.getControlElement(c2cDiv.firstChild);
								if (c2cChild) {
									if (!c2cChild.hasAttribute("tabindex")) {
										c2cChild.setAttribute('tabindex', 0);
									}
									c2cChild.focus();
								}
							}
							C2CMgr.lastusedC2CId = null;
						}, 300);
					}
				} else if(c2cData.launchable && !c2cData.c2cTheme.renderAsHTML) {
					C2CMgr.c2cBtnId = this.idx;
				}

		
	};	

	C2C.getControlElement = function(element) {
			if(element.tagName.toLowerCase() === "div") {
				return C2C.getControlElement(element.firstElementChild);
			} else {
				if (element.tagName.toLowerCase() === "style") {
					return C2C.getControlElement(element.nextElementSibling);
				}
			}
			return element;
		};

	C2C.prototype.addVirtualListener = function() {
		if (!isNullOrUndefined(C2C.VirtualKeyboardOpenCloseHandler)) {
			C2C.VirtualKeyboardOpenCloseHandler.addListener(this.c2cData);
		}
	};

	C2C.prototype.fixC2CLocation= function(eDiv) {
		var isTablet = this.c2cData.deviceType === "Tablet";
		var isAndroid = getOSType() === "Android";
		var elem, style,clientWidth, vpWidth;
		var docElem;
		var zoom;
		if (isTablet && isAndroid) {
			elem = eDiv;
			style = getComputedStyle(elem);
			/*
			 * Compute the overall width of the client using the position and width of the C2C button.
			 * clientWidth will be NaN is any of the values is not numeric.
			 */
			clientWidth = parseInt(style.left) + parseInt(style.width) + parseInt(style.right);
			vpWidth = window.innerWidth;
			if (!isNaN(clientWidth) && clientWidth > vpWidth) {
				docElem = window.document.documentElement;
				if (docElem.style.zoom === "") {
					zoom = (vpWidth/clientWidth)*100;
					docElem.style.zoom = zoom+"%";
				}
			}
		}
	};

	C2C.prototype.updateContainerStyle = function(ediv) {
		/** @type {?HTMLElement} */
		var element = ediv;
		/** @type {?HTMLElement} */
		var child = element ? element.children[0] : null;
		if (child) {
			/** @type {?string} */
			var styleText = child.getAttribute("data-parent-style");
			if (child.children[0] && styleText == null || styleText == "") {
				styleText = child.children[0].getAttribute("data-parent-style");
			}

			if (styleText != null && styleText != "") {
				this.parentPositionStyle = this.parseStyle(styleText);
				// initially apply the style
				this.applyStyle(element, this.parentPositionStyle);

				// then correct it, if the position will be out of visual viewport
				// Currently, uses only for Chrome and WebView browsers on Android devices.
				if ("Android" == getOSType() && styleText.contains("position") && styleText.contains("fixed")) {
					if (isAndroidWebView()) {
						if (this.parentPositionStyle.bottom != null && this.parentPositionStyle.top == null) {
							this.updateIconPosition(ediv);
							this.addListener(window.top, "scroll", this.updateIconPositionAfterDelay.bind(this));
						}
						this.addListener(window.top, "orientationchange", this.updateIconPositionToInitial.bind(this,eDiv));
					} else if (isChrome()) {
						if (this.isChangePositionNeeded()) {
							var img = element.getElementsByTagName("img")[0];
							var inputEl = element.getElementsByTagName("input")[0];
							if (!img && inputEl && inputEl.type == "image") {
								img = inputEl;
							}
							if (img && !img.complete) {
								var onloadListener = img.onload;
								img.onload = function() {
									if (typeof onloadListener == "function") {
										onloadListener();
									}
									this.updateIconPosition();
								}.bind(this);
							} else {
								this.updateIconPosition();
							}
						}
						this.addListener(window.top, "orientationchange", this.updateIconPositionAfterDelay.bind(this));
					}
				}
			}
		}
	};

	C2C.prototype.isChangePositionNeeded = function() {
		var docEl = top.document.documentElement;
		var docRatio = docEl.scrollWidth / docEl.scrollHeight;
		var screenRatio = screen.width / screen.height;
		return docRatio > screenRatio;
	};

	C2C.prototype.updateIconPositionToInitial = function(eDiv) {
		this.applyStyle(eDiv, this.parentPositionStyle);
		this.positionChanged = false;
		this.updateIconPositionAfterDelay();
	};


	C2C.prototype.updateIconPositionAfterDelay = function() {
		setTimeout(function() {
			this.updateIconPosition();
		}.bind(this), 500);
	};

	C2C.prototype.parseStyle = function(styleText) {
		var style = {};
		var styleList = styleText.split(";");
		for (var i = 0, item; i < styleList.length; i++) {
			item = styleList[i].split(":");
			if (!item[0]) continue;
			style[item[0].trim()] = item[1] ? item[1].trim() : "";
		}
		return style;
	};

	C2C.prototype.applyStyle = function(element, style) {
		/* Collects the new styles and removes value of previous style
		   which has a different displaying when they defined as single or pair, e.g. when 'position: absolute':
		       - when specified only 'left: 10px' then element will be located on the left;
		       - when specified two positions 'left: 10px; right: 10px;'
		         then the element will be extended from left to the right.
		 */
		var stylePositionController = {
			stylesMap: {},
			appliedProperty: [],
			addProperty: function(name) {
				this.appliedProperty.push(name);
			},
			clearExcessivePropertyValue: function(element) {
				for (var i = 0; i < this.appliedProperty.length; i++) {
					switch (this.appliedProperty[i]) {
						case "top":
							if (this.appliedProperty.indexOf("bottom") == -1) {
								element.style.bottom = "";
							}
							break;
						case "bottom":
							if (this.appliedProperty.indexOf("top") == -1) {
								element.style.top = "";
							}
							break;
						case "left":
							if (this.appliedProperty.indexOf("right") == -1) {
								element.style.right = "";
							}
							break;
						case "right":
							if (this.appliedProperty.indexOf("left") == -1) {
								element.style.left = "";
							}
							break;
					}
				}
			}
		};

		if (typeof style == "string") {
			style = this.parseStyle(style);
		}

		stylePositionController.stylesMap = style;
		for (var prop in style) {
			element.style[prop] = style[prop];
			stylePositionController.addProperty(prop);
		}

		stylePositionController.clearExcessivePropertyValue(element);
	};

	C2C.prototype.addEventHandlers = function (div, idx, eventName, c2cData, state) {
		var that = this;
		var eventHandler = function() {
			deviceType = c2cData.deviceType;
			if(c2cData.isPersistentChat) {
				var theme = c2cData.chatTheme;
				C2CMgr.earlyPopoutChat(theme);
			}
			if(c2cData.image == c2cmgr.IMAGETYPES.minimized) {
				NuanMessaging.SDKAPI.onRestoredClicked(); 
			} else {
				NuanMessaging.CIAPI.onC2CClicked(idx);	
			}
			
			return false;
		};

		var mouseoverHandler = function(e) {
			e = e || window.event;
			var targ = e.target || e.srcElement;
			if (targ.nodeType == 3) targ = targ.parentNode; // defeat Safari bug
			targ.style.cursor = "pointer";
		};
		window.setTimeout(function () {
			var element = div.firstChild;//get the target element
			if (element) {
				element[eventName] = eventHandler;
				element.onmouseover = mouseoverHandler;
			}
		}, 300);

	};

	C2C.prototype.updateIconPosition = function(eDiv) {
		/** @type {HTMLElement} */
		var element = eDiv;
		/** @type {Object} */
		var style = copy(this.parentPositionStyle);
		var rollBackChanges = false;
		var styleChanged = false;
		var newTop;

		if (isAndroidWebView()) {
			if (window.top.pageYOffset <= 0) {
				if (isElementOutsideOfViewport(0)) {
					newTop = newTopPosition(0);
					styleChanged = true;
				}
			} else if (this.positionChanged) {
				rollBackChanges = true;
			}
		} else {
			if (this.isChangePositionNeeded()) {
				if (this.positionChanged) {
					if (isElementOutsideOfViewport(0)) {
						newTop = newTopPosition(0);
						styleChanged = true;
					}
				} else if (style.bottom != null && style.top == null) {
					var bottomPosition = parseInt(style.bottom);
					if (!isNaN(bottomPosition)) {
						if (isElementOutsideOfViewport(bottomPosition)) {
							newTop = newTopPosition(bottomPosition);
							styleChanged = true;
						}
					}
				}
			} else if (this.positionChanged) {
				rollBackChanges = true;
			}
		}

		if (styleChanged) {
			style.top = newTop + "px";
			delete style.bottom;

			this.applyStyle(element, style);
			this.positionChanged = true;
		} else if (rollBackChanges) {
			this.applyStyle(element, this.parentPositionStyle);
			this.positionChanged = false;
		}

		function isElementOutsideOfViewport(bottom) {
			// is checked only bottom position
			// Summarized the value of bottom,
			// because element can be visible due to the fact that it has an indent from bottom,
			// but thus it can be located incorrectly,
			// because it should be moved from bottom onto the specified value.
			return element.getBoundingClientRect().bottom + bottom > window.top.document.documentElement.scrollHeight;
		}

		function newTopPosition(bottom) {
			return window.top.document.documentElement.scrollHeight - element.offsetHeight - bottom;
		}

		/* The simple copy of object. This is enough for object containing the list of styles property. */
		function copy(object) {
			var out = {};
			for (var k in object) {
				out[k] = object[k];
			}
			return out;
		}
	};



	C2C.prototype.getDiv = function(divId) {
		return window.document.getElementById(divId);
	};

	C2C.prototype.isDivOccupied = function(divEl) {
		var el  = divEl;
		if(!el){
			return true;
		}
		return (!!el.occupied);
	};

	C2C.prototype.showDisabled = function() {
		if(this.div) {
			this.showIcon(c2cmgr.IMAGETYPES.disabled, false,this.c2cData,this.div,true);
		}
	};

	C2C.prototype.addListener = function(target, type, listener) {
		attachListener(target, type, listener);
		this.listeners.push({
			target: target,
			type: type,
			listener: listener
		});
	};

	C2C.prototype.clearListeners = function() {
		for (var i = this.listeners.length; i--;) {
			detachListener(this.listeners[i].target, this.listeners[i].type, this.listeners[i].listener);
		}
	};

	C2C.prototype.clear = function(){
		if(this.div) {
			this.div.occupied = false;
			this.div.innerHTML="";
		}
	};

	//can comment till here

	C2CMgr.earlyPopoutChat = function(cT){
		var winTest = null ;
		var url="", target = "_inqPersistentChat";
		var tools = "toolbar=no,location=no,menubar=no,status=no,scrollbars=no" +
					",top=" + cT.py +
					",left=" + cT.px +
					",width=" + (config.frameW ? config.frameW : cT.pw) +
					",height=" + (config.frameH ? config.frameW : cT.ph) +
					",resizable=1" ;
		try {
			if(getOSType() == "Android" || getOSType() == "iOS") { return; }
			winTest = top.open(url, target, tools);		
		} catch (e1) {
			winTest = null;
		}

		C2CMgr.earlyPopout = winTest ; // Window of the soon-to-be pop-out chat
	};


	C2CMgr.getPersistentWindow = function(c2cInstance, displayState) {
		if (window.parent.name == "_inqPersistentChat") {
			return true;
		}
		var winTest = null ;
		var toolsForTest = "toolbar=no,location=no,menubar=no,status=no,scrollbars=no" +
				",top="+ "-500" +
				",left=" + "-500" +
				",width="+"0" +
				",height="+"0" +
				"";
		try {
			if (c2cInstance.popoutWindow && c2cInstance.popoutWindow.closed) {
				c2cInstance.popoutWindow = null;
				return null;
			}
			if(displayState == "chatactive"){

			} else if (!c2cInstance.popoutWindow) {
				return null;
			}

			/* If we have the window of the soon-to-be pop-out chat (earlyPopout) ...
			 * Then we don't have an active popout chat, yet
			 */
			if (C2CMgr.earlyPopout) {
				return null;
			}

			winTest = window.open("", "_inqPersistentChat", toolsForTest);
			if (winTest != null) {
				//if ("about:blank" ==  winTest.location.href || !winTest.document || !winTest.document.body || "" === winTest.document.body.innerHTML) {
				//	winTest.close();
				//	winTest = null;
				//}
				if (winTest == top || winTest == self) {
					winTest = null;
				} else {
					winTest.postMessage(JSON.stringify(new Message("SET_PER_WIN")),"*");
				}
			}
			c2cInstance.popoutWindow = winTest;
		} catch (e) {
			winTest = null; // there used to be a string called "something" here.
			//winTest should be returning null or else the non popup chat will show in the check for a persistent window.
		}
		return winTest;
	};


	C2C.VirtualKeyboardOpenCloseHandler = {
		addListener: function (c2cData) {
			if (c2cData.deviceType === "Phone" && !isIOS()) {
				var keyboardDetectionThreshhold = 200;
				var c2cId = c2cData.pageElementID;
				this.c2cHandler = function() {
					var c2cBtn = getElementById(c2cId);
					if (!isNullOrUndefined(c2cBtn)) {
						
						var zoomRatio = window.top.screen.width/window.top.innerWidth;
						var innerHeight = window.top.innerHeight*zoomRatio;
						var screenHeight = window.top.screen.height;
						if ((screenHeight - innerHeight) > keyboardDetectionThreshhold) {  // virtual keyboard present.
							c2cBtn.style.display = "none";
						} else {
							c2cBtn.style.display = "block";
						}
					}
				};
				window.removeEventListener("resize", this.c2cHandler);
				window.addEventListener("resize", this.c2cHandler);
			}
		},
		removeListener: function(c2cData) {
			if (c2cData.deviceType === "Phone" && !isIOS()) {
				window.removeEventListener("resize", this.c2cHandler);
			}
		}
	};

    	function ScrollMonitor(){

	}
	ScrollMonitor.getScrollLeft = function() {
		try {
			var clientWin = window.parent;
			var clientDoc = clientWin.document;
			if (null != clientWin.pageXOffset) {
				return clientWin.pageXOffset;
			}
			if (clientDoc.documentElement != null && (clientDoc.documentElement.scrollLeft != null && clientDoc.documentElement.scrollLeft != 0)) {
				return clientDoc.documentElement.scrollLeft;
			}
			else {
				return clientDoc.body.scrollLeft;
			}
		} catch(e){}
		return 0;
	};

	ScrollMonitor.getScrollTop = function() {
		try {
			var clientWin = window.parent;
			var clientDoc = clientWin.document;
			if (null != clientWin.pageYOffset) {
				return clientWin.pageYOffset;
			}

			if (clientDoc.documentElement != null && (clientDoc.documentElement.scrollTop != null && clientDoc.documentElement.scrollTop != 0)) {
				return clientDoc.documentElement.scrollTop;
			}
			else {
				return clientDoc.body.scrollTop;
			}
		} catch(e){}
		return 0;
	};

ScrollMonitor.getScrollWidth = function() {
	var clientWin = window.parent;
	var clientDoc = clientWin.document;
	var iScrollWidth = 0;

	if (null == clientWin.innerWidth) {
		iScrollWidth = clientDoc.documentElement != null ? 0 != clientDoc.documentElement.clientWidth ? clientDoc.documentElement.clientWidth : clientDoc.body.clientWidth : clientDoc.body.clientWidth;
	}
	else {
		var innerWidth = clientWin.innerWidth;
		// If necessary, adjust innerWidth to reflect the presence of the scroll bar.
		innerWidth -=
			ScrollMonitor.hasRightScrollBar() ? ScrollMonitor.getScrollBarWidth() : 0;
		var clientWidth = clientDoc.body.clientWidth;
		/** on a Tablet we should use innerwidth as the scroll width because as user zooms in innerwidth shrinks and as user zoom out innerwidth expands. */
		if (isTablet()) {
			iScrollWidth = innerWidth;
		}
		else {
			iScrollWidth = (clientWidth == 0) ? innerWidth : Math.min(clientWidth, innerWidth);
		}
		if (0 == iScrollWidth) iScrollWidth = clientDoc.body.clientWidth;
	}
	return iScrollWidth;
};

ScrollMonitor.getScrollHeight = function () {
	var iScrollHeight = 0;
	var clientDoc = window.parent.document;

	if (null == window.parent.innerHeight) {
		iScrollHeight = clientDoc.documentElement != null? 0 != clientDoc.documentElement.clientHeight ? clientDoc.documentElement.clientHeight : clientDoc.body.clientHeight : clientDoc.body.clientHeight;
	}
	else {
		var innerHeight = window.parent.innerHeight;
		// If necessary, adjust innerHeight to reflect the presence of the scroll bar.
		innerHeight -=
			ScrollMonitor.hasBottomScrollBar() ? ScrollMonitor.getScrollBarWidth() : 0;

		// BEWARE browser bugs: clientHeight often reflects a value more like offsetHeight, NOT the correct,
		// visible height of the element. When this happens, it's too BIG, so we apply Math.min below.
		var clientHeight = clientDoc.body.clientHeight;
		var scrollHeight = clientDoc.body.scrollHeight;

		// We need to make sure the page is long enough to fill the screen. If it's not, then the clientHeight
		// is useless. We detect this by checking that the clientHeight >= scrollHeight.
		iScrollHeight = 0;
		if (clientHeight == 0 || scrollHeight >= clientHeight) { // Ensures that the page is tall enough to fill the window
			iScrollHeight = innerHeight;
		}
		else {
			iScrollHeight = Math.min(clientHeight, innerHeight);
		}

		if (0 == iScrollHeight) {
			iScrollHeight =
				clientDoc.body.clientHeight;
		}
	}
	return iScrollHeight;
};

ScrollMonitor.hasRightScrollBar = function() {
	var clientHeight = window.parent.document.documentElement.clientHeight;
	var clientWidth =  window.parent.document.documentElement.clientWidth;
	var scrollHeight = window.parent.document.documentElement.scrollHeight;
	var innerWidth = window.parent.innerWidth;
	// This means we need to scroll.
	return (clientHeight < scrollHeight) || (clientWidth < innerWidth); // Indicates that a grayed-out scroll bar already appears.
};

ScrollMonitor.hasBottomScrollBar = function() {
	var clientWidth = window.parent.document.documentElement.clientWidth;
	var scrollWidth = window.parent.document.documentElement.scrollWidth;
	var clientHeight = window.parent.document.documentElement.clientHeight;
	var innerHeight = window.parent.innerHeight;
	   // This means we need to scroll
	return (clientWidth < scrollWidth) || (clientHeight < innerHeight); // Indicates that a grayed-out scroll bar already appears.
};

ScrollMonitor.getScrollBarWidth = function () {
	/** @type {Element} */
	var scr;
	/** @type {Element} */
	var inn;
	/** @type {number} */
	var wNoScroll;
	/** @type {number} */
	var wScroll;

	/*  Outer scrolling div */
	scr = window.parent.document.createElement("div");
	scr.style.position = "absolute";
	scr.style.top = "-1000px";
	scr.style.left = "-1000px";
	scr.style.width = "100px";
	scr.style.height = "50px";
	/*  Start with no scrollbar */
	scr.style.overflow = "hidden";

	/*  Inner content div */
	inn = window.parent.document.createElement("div");
	inn.style.width = "100%";
	inn.style.height = "200px";

	/*  Put the inner div in the scrolling div */
	scr.appendChild(inn);
	/*  Append the scrolling div to the doc */

	window.parent.document.body.appendChild(scr);

	/*  Width of the inner div sans scrollbar */
	wNoScroll = inn.offsetWidth;
	/*  Add the scrollbar */
	scr.style.overflow = "auto";
	/*  Width of the inner div width scrollbar */
	wScroll = inn.offsetWidth;

	/*  Remove the scrolling div from the doc */
	window.parent.document.body.removeChild(window.parent.document.body.lastChild);

	/*  Pixel width of the scroller */
	return wNoScroll - wScroll;
};

ScrollMonitor.getViewport = function() {
	/** @type {number} */
	var x = ScrollMonitor.getScrollLeft();
	/** @type {number} */
	var y = ScrollMonitor.getScrollTop();
	/** @type {com.inq.utils.Area} */
	var w = parseInt(window.parent.innerWidth);
	/** @type {?number} */
	var h = parseInt(window.parent.innerHeight);
	var vp = new Area(x, y, w, h);
	
	return vp;
};

    /**
* MessageWindow class controls the width, height and position of the chat window
*/

	function MessageWindow() {
		this.iframe = document.getElementById(config.frameID);
		this.area = null;
		this.resizeHandler = debounce(this.resizeEvent.bind(this),100);
		if(isIOS()){
			this.scrollHandler = debounce(this.scrollDebouncedEvent.bind(this),100);
			this.moveScrollHandler = this.touchMoveScrollHandler.bind(this);
			this.iphoneModel = getIphoneModel();
		}
		MessageWindow.bottomDelta = 0;
		if(disableC2Crender && bootstrapC2cInstance != null && bootstrapC2cInstance.isCloseBtnDisplayed()) {
			MessageWindow.bottomDelta += bootstrapC2cInstance.getHeight();
		}
		this.chatActive = false;
		this.chatframe = this.iframe.querySelector("iframe");
	}

   /**
   * render the iframe either with the position from theme or the one set in bootstrap config
   */
	MessageWindow.prototype.render = function(theme) {
		var __height;
		/** @type {number} */
		var __width;
		/** @type {Window} */
		var __winParent = window.parent;
		/** @type {com.inq.utils.Area} */
		var vp = ScrollMonitor.getViewport();
		var position ;
		this.theme = theme;
		if(!minimized && theme.minimized && theme.minimized.state) {
			this.chatActive = true;
			if(isPhone()) {
				this.resizeForPhone(vp);
			} else {
				this.setDesktopArea();
				this.setWH();				
			}
			minimized = true;
			minimizedCount = theme.minimized.count;
			theme.reDisplay = true;
			c2cmgr.render(theme);
			this.setVisible(false);
			this.chatframe.style.display = "block";
			return;
		} 
						
		if(isPhone()) {
			/**
			IOS safari we need to turn off the user scalaing option to no, it is under impression that there is already a viewport tag present
			**/
			if(isIOS()) {
				this.addViewPort();
				detachListener(window,"scroll",this.scrollHandler);
				attachListener(window,"scroll", this.scrollHandler);
				document.body.classList.add("chatopen");
				window.scrollTo(0, 1); 
			} else {
				document.documentElement.style.overflow = 'hidden';
			}
			__width = vp.width;
			__height = vp.height;
			window.requestAnimationFrame(function() {
				this.resizeForPhone(vp);
				this.addAriaToParent();
			}.bind(this));
			
			

		} else {		
			this.setDesktopArea();
			window.requestAnimationFrame(function() {
				this.setWH();
				this.resizeWindow();
				this.resizeEvent();
			}.bind(this));
		}
		detachListener(window,"resize",this.resizeHandler);
		attachListener(window,"resize", this.resizeHandler);

		this.chatframe.removeAttribute("aria-hidden");	
		this.chatframe.removeAttribute('hidden');
		this.chatframe.style.display = null;
		this.addDragElement(theme);
		this.chatActive = true;
	};

	MessageWindow.prototype.setDesktopArea = function() {
		this.area = new Area();	
		this.area.width = config.frameW? config.frameW :this.theme.skinWidth;
		this.area.height = (config.frameH? config.frameH : this.theme.skinHeight + this.theme.titleBarHeight )  + MessageWindow.bottomDelta ;	
	};

	/**
	*
	*/

	MessageWindow.prototype.resizeForPhone = function(){

		if (this.isMinimized() || !this.chatActive) {
			return;
		}

		var vp = ScrollMonitor.getViewport();
		if (this.area){
			//if(vp.height < this.area.height) {
				//fireMesageToBridge(new Message("KEYBOARD_OPEN"));	
			//}
		}

		this.area = new Area(0, 0, vp.width, vp.height);
		this.setWH();
		this.updatePosition();	
		
	};

	MessageWindow.prototype.addViewPort = function() {
		this.metaTag=document.createElement('meta');
		this.metaTag.name = "viewport";
		this.metaTag.content = "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0";
		document.getElementsByTagName('head')[0].appendChild(this.metaTag);
	};

	MessageWindow.prototype.scrollDebouncedEvent = function() {
		if(this.scrollState == 1) {			
			this.scrollState = 0;
			//this.virtualKeyboardDisplayed();
			if(this.forceScrollTimer){	
				clearTimeout(this.forceScrollTimer);								
			}
			setTimeout(function() {	
				this.isVirtualKeyboardPresent = true;
	          	window.scrollTo(0, 0);      
	          	setTimeout(function() {	
	          		if(this.scrollState == 2) {
	          			this.scrollDebouncedEvent();
	          		}
	          	}.bind(this),250) ;
	          	this.scrollState = 2;   	
	      	}.bind(this), 200);
			return;
		}


		if(this.isVirtualKeyboardPresent == true) {
			this.scrollState = 0; 
			var vp = ScrollMonitor.getViewport();
			var frame = this.iframe.querySelector("iframe");
			var keyboardH;
			if (visualViewport) {
			  	keyboardH = vp.height - getVisualViewportHeight();	
			} else {
				keyboardH = vp.height > vp.width? this.area.height * (MessageWindow.keyBoardValuePort[this.iphoneModel] || 0.43) : this.area.height * 0.60;
			}
        	this.iframe.style.height = null;
			this.iframe.style.bottom = keyboardH + "px";

            var iFrameStyle = getComputedStyle(this.iframe);
            var viewportHeight = parseInt(vp.height, 10);
            var iFramePaddingTop = parseInt(iFrameStyle.paddingTop, 10);
            var iFramePaddingBottom = parseInt(iFrameStyle.paddingBottom, 10);
            var iFrameVerticalPadding = iFramePaddingTop + iFramePaddingBottom;

            frame.style.height = (viewportHeight - keyboardH - iFrameVerticalPadding) + "px";

        	this.reLayout();
        	this.scrolled = window.top.pageYOffset;
        	if(keyboardH == 0) {
        		this.scrollState = 1;
        		this.isVirtualKeyboardPresent = false; 
        	} else {
        		detachListener(window,"scroll",this.scrollHandler);
        		detachListener(window, "scroll", this.moveScrollHandler);
            	attachListener(window, "scroll", this.moveScrollHandler);
            	fireMesageToBridge(new Message("KEYBOARD_OPEN"));		
        	}
        			
    	}
	};

	MessageWindow.prototype.virtualKeyboardDisplayed = function() {
		//this.isVirtualKeyboardPresent = false;
		if(isIpad()) {

		} else {
			this.isVirtualKeyboardPresent = false;
			this.iframe.style.bottom = null;
			detachListener(window, "scroll", this.moveScrollHandler);
			detachListener(window,"scroll",this.scrollHandler);
			attachListener(window,"scroll", this.scrollHandler);

	      	this.scrollState = 1;
	      	this.forceScrollTimer = setTimeout(function() {			
				window.scrollBy(0, 10);	
			},200);
      	}
	};

	MessageWindow.prototype.virtualKeyboardHidden = function() {
		if(isIpad()) {

		} else {

			if (this.kbHiddenTimer) {
				clearTimeout(this.kbHiddenTimer);
			}
			this.kbHiddenTimer = setTimeout(function(){
				var vp = ScrollMonitor.getViewport();
				this.isVirtualKeyboardPresent = false;
				this.iframe.style.bottom = null;		
				this.resizeForPhone(vp);
				this.kbHiddenTimer = null;
			}.bind(this), 250);
			detachListener(window, "scroll", this.moveScrollHandler);
		}	
	};
	
	MessageWindow.prototype.touchMoveScrollHandler = function(e) {		
        e.preventDefault();
        e.stopPropagation();
        window.top.scrollTo(0, this.scrolled);        
    };

	/**
	* Responsively adjust the position and width height of chat window when the page resize 
	*/
	MessageWindow.prototype.resizeEvent = function(){
		if(this.timeout) {
			window.cancelAnimationFrame(this.timeout);
		}

		this.timeout = window.requestAnimationFrame(function() {
			var vp = ScrollMonitor.getViewport();
			if(isPhone()){
				this.resizeForPhone(vp);
				if(isIOS() && this.isVirtualKeyboardPresent) {

					if(vp.width > vp.height) {
						this.scrollDebouncedEvent();
					} else {
						this.scrollState = 1;
						detachListener(window,"scroll",this.scrollHandler);
						attachListener(window,"scroll", this.scrollHandler);
						this.forceScrollTimer = setTimeout(function() {			
							window.scrollBy(0, 10);	
						},200);
					} 
					
					
					
				} else if(isIOS()){
					setTimeout(function() {			
			          	window.scrollTo(0, 0);          	
			      	}, 200);
				}

				fireMesageToBridge(new Message("KEYBOARD_OPEN"));	
				
			} else {
				if(ScrollMonitor.getScrollHeight() > parseInt(this.iframe.style.height)) {
					if(this.iframe.classList.contains("adjust-height")) {
						this.iframe.classList.remove("adjust-height");
						fireMesageToBridge(new Message("FULL_SCREEN", false));
					}
					this.resizeWindow();
					this.area.height = parseInt(this.iframe.style.height);
				} else {
					if(!this.iframe.classList.contains("adjust-height")) {
						this.iframe.classList.add("adjust-height");
						fireMesageToBridge(new Message("FULL_SCREEN", true));						
					}
					this.area.height = ScrollMonitor.getViewport().height;
				}

				if(ScrollMonitor.getScrollWidth() > parseInt(this.iframe.style.width)) {
					if(this.iframe.classList.contains("adjust-width")) {
						this.iframe.classList.remove("adjust-width");
					}
					this.resizeWindow();
					this.area.width = parseInt(this.iframe.style.width);
				} else {
					if(!this.iframe.classList.contains("adjust-width")) {
						this.iframe.classList.add("adjust-width");					
					}
					this.area.width = ScrollMonitor.getViewport().width;
				}
			}
		}.bind(this));
	};

	MessageWindow.prototype.setWH = function() {
		
		var frame = this.iframe.querySelector("iframe");
		var st = getComputedStyle(this.iframe);
		this.iframe.style.width = this.area.width  + "px";
		
		frame.classList.add("enter");
		frame.style.width = this.area.width - (parseInt(st.paddingLeft) + parseInt(st.paddingRight)) + "px";
		this.iframe.style.height  = this.area.height  +"px";
		if(isPhone()) {
			frame.style.height = (this.area.height - (parseInt(st.paddingTop) + parseInt(st.paddingBottom)) + "px");
		} else {
			frame.style.height = (this.area.height - MessageWindow.bottomDelta - (parseInt(st.paddingTop) + parseInt(st.paddingBottom)) + "px");
		}
		//frame.style.bottom = MessageWindow.bottomDelta+"px";

	};

	/**
	* determine the size , position of chat widnow, reuse the position even after page reload
	*/

	MessageWindow.prototype.resizeWindow = function() {
		
		//var vp = ScrollMonitor.getViewport();
		var __width = this.area.width;
		var __height = this.area.height;
		var position;

		if(this.theme.skinRightSaved != -1 && this.theme.skinBottomSaved != -1) {
			position = new Point();
			position.p1 = this.theme.skinRightSaved;
			position.p2 = this.theme.skinBottomSaved;
		} else {

			position = MessageWindow.calcChatLocation(
				__width,
				__height,
				this.theme.skinLeft, /** its is bottom for websdk */
				this.theme.skinTop,
				config.framePos? config.framePos :this.theme.skinPosition
			);
		}
				
		//if (__height < vp.height && __width < vp.width) {
			position.p1 = MessageWindow.setFixedRPosition(position.p1, __width);
			position.p2 = MessageWindow.setFixedBPosition(position.p2, __height);
		//} 
		this.area.setBRPosition(position.p1, position.p2, __width, __height);
		this.updatePosition(__width, __height);
	};

	/**
	* handle the drag reposition of chat window
	*/

	MessageWindow.prototype.moveStage = function(left,top) {
		var position = new Point();
		//position.x = MessageWindow.setAbsoluteXPosition(left, this.area.width);
		//position.y = MessageWindow.setAbsoluteYPosition(top, this.area.height);

		//this.updatePosition(position.x,position.y,this.area.width,this.area.height);
		//this.updateDragResizePos();

		
		var vp = ScrollMonitor.getViewport();
		var right = ScrollMonitor.getScrollWidth() - (left + this.area.width);
		var bottom = ScrollMonitor.getScrollHeight() - (top + this.area.height);
		this.area.setBRPosition(right, bottom, this.area.width, this.area.height);
		fireMesageToBridge(new Message("UPDATE_CHAT_POSITION", this.area));
		this.updatePosition();
		this.theme.skinRightSaved = right;
		this.theme.skinBottomSaved = bottom;

	};

	/*
	MessageWindow.prototype.resizeStage = function(w, h) {
		this.updatePosition(this.area.x, this.area.y, w, h);
		this.updateDragResizePos();
		fireMesageToBridge(new Message("UPDATE_CHAT_POSITION", this.area));
	}
	*/

	/**
	* handle the drag bar element , drag bar width and height is set in portal
	*/

	MessageWindow.prototype.addDragElement = function(theme) {
		if(config.isDragEnabled() && !isPhone()){

			var titleBarEl = this.titleBarEl = new Element("nuanTitleBar");
			MessageWindow.clearImage = theme.imagePath + "clear.gif";
			var tc = config.getUIConfig() && config.getUIConfig().topBarConfig, ts = {}; 
			if(tc) {
				ts = tc.topBarSettings;
			}
			titleBarEl.addCssText("position:absolute; z-index: 9999999; height: 1px; width: 1px; left: 0px; top: 0px; cursor:move; borderThickness:0px");
			titleBarEl.setInnerHTML("<input type=\"image\" src=\"" + MessageWindow.clearImage + "\" style=\"position:static;cursor:move;\" alt=\"\" tabindex=\"-1\"/>");
			titleBarEl.setStyle("height",theme.adjustDragBarHeight || ts.adjustDragBarHeight || (theme.titleBarHeight + "px"));
			titleBarEl.setStyle("width",theme.adjustDragBarWidth || ts.adjustDragBarWidth || (this.area.width - theme.dragAreaOffset + "px"));
			if(theme.adjustDragBarLeft || ts.adjustDragBarLeft) titleBarEl.setStyle("left",theme.adjustDragBarLeft || ts.adjustDragBarLeft) ;
	

			titleBarEl.appendToParent(this.iframe);
			
			/*
			var resizeCorner = this.inqResizeCorner = new Element("nuanResizeCorner");
			resizeCorner.addCssText("position: absolute; right: 0px; bottom: 0px; cursor:se-resize; borderThickness:0px");
			
			resizeCorner.setAttribute("alt", "");
			resizeCorner.setAttribute("aria-hidden", "true");
			resizeCorner.setAttribute("tabindex", "-1");


			resizeCorner.setInnerHTML("<input type=\"image\" src=\"" + theme.imagePath + "ResizeCorner.gif" + "?rand=" + Math.random() + "\""
					+ "style=\"position: absolute; top:0px; left:0px; height: 100%; width: 100%; bottom: 0px; right: 0px; display: block; cursor:se-resize;\" tabindex=\"-1\"/>");

			
			resizeCorner.setStyle("width", MessageWindow.resizeArea.width + "px");
			resizeCorner.setStyle("height", MessageWindow.resizeArea.height + "px");
			resizeCorner.appendToParent(window.document.body);
			*/
			//this.updateDragResizePos();
			Move.setDragable(theme.dragMode || config.getUIConfig() && config.getUIConfig().appConfigProps.dragMode);
			//Resize.setResizable();
		}
	};
		/*MessageWindow.prototype.updateDragResizePos = function() {
		this.titleBarEl.setStyle("left",this.area.x + "px");
		this.titleBarEl.setStyle("top", this.area.y + "px");
			
			this.inqResizeCorner.setStyle("left", this.area.x + this.area.width - MessageWindow.resizeArea.width + "px");
			this.inqResizeCorner.setStyle("top", this.area.y + this.area.height - MessageWindow.resizeArea.height + "px");
			this.inqResizeCorner.setStyle("zIndex", 9999999 + 1);
		
	}*/
	/*
	MessageWindow.getDefaultResizeArea = function() {
		var a;
		if (isMobile()) {
			a = new Area(0, 0, 32, 32);
		} else {
			a = new Area(0, 0, 16, 16);
		}
		return a;
	}


	MessageWindow.resizeArea = MessageWindow.getDefaultResizeArea();
	*/

	MessageWindow.prototype.updatePosition = function(width, height) {
		//if(width < MessageWindow.minWidth) width = MessageWindow.minWidth;
		//if(height < MessageWindow.minHeight) height = MessageWindow.minHeight;		
		this.reLayout();


	};

	MessageWindow.prototype.reLayout = function() {
		if(this.area.isXYAxisPos()) {
			this.iframe.style.left = this.area.x + "px";
			this.iframe.style.top = this.area.y + "px";
		} else {
			this.iframe.style.right = this.area.r + "px";
			this.iframe.style.bottom = this.area.b + "px";
			this.iframe.style.left = this.iframe.style.top = null;

		}
		
	};

	MessageWindow.prototype.addAriaToParent = function() {
 		//edit by client

 		//fireMesageToBridge(new Message("READY_FOCUS", false));
	};

	MessageWindow.prototype.removeAriaFromParent = function() {
 		//edit by client
	};

    /**
	* set the visibility of iframe to none when minimize state is fired
	*/
	MessageWindow.prototype.minimize = function() {
		this.setVisible(false);
		minimized = true;
	};

	MessageWindow.prototype.isMinimized = function() {
		return minimized;
	};

	MessageWindow.prototype.setVisible = function(visible) {
		var frame = this.iframe.querySelector('iframe');
		if(visible) {	
			frame.style.display = null;		
			this.render(this.theme);
			minimized = false;
			if (minimizedCount > 0) {
				fireMesageToBridge(new Message("KEYBOARD_OPEN"));
			} 
			minimizedCount = 0;
			this.addAriaToParent();
		} else {
			detachListener(window,"resize",this.resizeHandler);
			if(this.titleBarEl) {
				var dragInst = this.titleBarEl.div[DragResize.INSTANCE_LABEL];
				if(dragInst) {
					dragInst.clear();
				}
				this.titleBarEl.delete();
			} else {
				detachListener(window,"scroll",this.scrollHandler);
				detachListener(window, "scroll", this.moveScrollHandler);
				if(isIOS()) {
					if(this.metaTag){
						this.metaTag.parentElement.removeChild(this.metaTag);
					}
					document.body.classList.remove("chatopen");
				} else {
					document.documentElement.style.overflow = 'scroll';
				}
			}		
			
			this.iframe.classList.remove("adjust-height");
			this.iframe.classList.remove("adjust-width");
			
			frame.classList.remove("enter");
			this.iframe.style.height = "1px";
			this.iframe.style.width = "1px";
			this.iframe.style.top = null;
			this.iframe.style.left = null;
			
			this.isVirtualKeyboardPresent = false;
			this.iframe.style.bottom = null;		
			if (this.kbHiddenTimer) {
				clearTimeout(this.kbHiddenTimer);
			}
			this.removeAriaFromParent();
			this.area = null;
			frame.setAttribute("aria-hidden", true);
			frame.setAttribute("hidden", true);
			this.chatActive = false;
		}
	};

	MessageWindow.prototype.clear = function() {
		this.setVisible(false);
		var frame = this.iframe.querySelector('iframe');		
		frame.style.width = null;
		frame.style.height = null;
		
		setTimeout(function(){
			this.iframe.style.bottom = null;
			this.iframe.style.right = null;
			frame.style.display = "none";
		}.bind(this),500);
			
		

	};

	MessageWindow.setFixedRPosition = function(r,w) {
		return MessageWindow.FixR(r,w);
	};

	MessageWindow.setFixedBPosition = function(t,h) {

		return MessageWindow.FixB(t,h);
	};

	MessageWindow.FixR = function(r,w) {
		/** @type {number} */
		var right = r < 0?0:r;
		/** @type {number} */
		var left = right + w;
		/** @type {number} */
		var xMax = ScrollMonitor.getScrollWidth();
		if(left > xMax && right != 0) right = xMax - w;
		if(right < 0) right = 0;
		return right;
	};

	MessageWindow.FixB = function(b,h) {
		/** @type {number} */
		var bottom = b < 0?0:b;
		/** @type {number} */
		var scrollHeight = ScrollMonitor.getScrollHeight();
		/* Make sure that the Y position allows the
		 * chat to be totally visible in the window.
		 * 1) get the height of the scroll area (viewport)
		 * 2) subtract the height to yield the maximum absolute position
		 * 3) adjust if greater than.
		 */

		/** @type {number} */
		var yMax = scrollHeight - h;

		if(bottom > yMax && bottom != 0) bottom = yMax;
		if(bottom < 0) bottom = 0;
		return bottom;
	};

	MessageWindow.chatPositionPadding = 5;

	MessageWindow.calcChatLocation = function(W, H, X, Y, location) {
		/** @type {number} */
		var right = 0;
		/** @type {number} */
		var bottom = 0;
		/** @type {number} */
		var scrollBarWidth = 0;//isIE() ? 0 : ScrollMonitor.getScrollBarWidth();
		/** @type {boolean} */
		var isRightScrollBar = ScrollMonitor.hasRightScrollBar();
		/** @type {boolean} */
		var isBottomScrollBar = ScrollMonitor.hasBottomScrollBar();

		/** @type {number} */
		var inq_scroll_width;
		/** @type {number} */
		var inq_scroll_height;

		if (isIE()) {
			inq_scroll_height = window.parent.document.documentElement.clientHeight;
			if (inq_scroll_height == 0) {
				inq_scroll_height = window.parent.document.body.clientHeight;
			}
			inq_scroll_width = window.parent.document.documentElement.clientWidth;
			if (inq_scroll_width == 0) {
				inq_scroll_width = window.parent.document.body.clientWidth;
			}
		} else {
			inq_scroll_height = window.parent.innerHeight;
			inq_scroll_width = window.parent.innerWidth;
		}

		if (W < MessageWindow.minWidth) {
			W = MessageWindow.minWidth;
		}

		if (H < MessageWindow.minHeight) {
			H = MessageWindow.minHeight;
		}
			
		switch (location.toUpperCase()) {
			case "UPPER CENTER":case "UPPER_CENTER":case "TOP_CENTER":
				bottom = inq_scroll_height - H;
				right = inq_scroll_width / 2 - W / 2;
				break;
			case "UPPER_RIGHT":case "TOP_RIGHT":
				bottom = inq_scroll_height - H;
				right = (isRightScrollBar ? scrollBarWidth : 0);
				break;
			case "UPPER_LEFT":case "TOP_LEFT":
				bottom = inq_scroll_height - H;
				right = inq_scroll_width - W;
				break;
			case "CENTER_LEFT":
				bottom = inq_scroll_height / 2 - H / 2;
				right = inq_scroll_width - W;
				break;
			case "CENTER_RIGHT":
				bottom = inq_scroll_height / 2 - H / 2;
				right = (isRightScrollBar ? scrollBarWidth : 0);
				break;
			case "LOWER_LEFT":case "BOTTOM_LEFT":
				bottom = (isBottomScrollBar ? scrollBarWidth : 0);
				right = inq_scroll_width - W;
				break;
			case "LOWER_CENTER":case "BOTTOM_CENTER":
				bottom = (isBottomScrollBar ? scrollBarWidth : 0);
				right = inq_scroll_width / 2 - W / 2;
				
				break;
			case "LOWER_RIGHT":case "BOTTOM_RIGHT":
				right = (isRightScrollBar ? scrollBarWidth : 0);
				bottom = (isBottomScrollBar ? scrollBarWidth : 0);
				
				break;
			case "POP_UNDER_CENTER":
				right = inq_scroll_width / 2 - W / 2;
				bottom = inq_scroll_height / 2 - H;
				break;
			case "ABSOLUTE":
			case "FIXED":
				right = X;
				bottom = Y;
				break;
			case "RELATIVE":
				right = X;
				bottom = Y;
				break;
			case "CENTER":
				right = inq_scroll_width / 2 - W / 2 ;
				bottom = inq_scroll_height / 2 - H / 2 ;
				break;
		}

		if(right == null || right < 0) right = 0;

		if(null == bottom || top < 0) top = 0;
		/* return {top: top, left: left } ; */
		return new Point(right | 0,bottom | 0);
	};

	MessageWindow.keyBoardValuePort = {
		"iPhoneX": 0.45
	};

    
/**
* drag resize class handles the drag and drop of messaging chat window
*/

var DragResize = function() {
	this.className = "DragResize";
	this.styleSaved = "";
	this.cursor = "default";
	this.pDraggerNow = null;
	this.touchIdentifier = DragResize.TOUCH_IDENTIFER_UNUSED;
};

DragResize.o = null;
DragResize["typeof"] = function(v) {
	return typeof(v);
};

DragResize.WhenDone = function() {
	if(DragResize.instance != null) DragResize.instance.whenDone();
	DragResize.instance = null;
};


DragResize.prototype._removeEventListener = function(object,eventName,func) {
	detachListener(object,eventName,func);
};

DragResize.prototype._attachEventListener = function(object,eventName,func) {
	attachListener(object,eventName, func);
};


DragResize.prototype.bindClosures = function() {
	this.uponTouchStartClosure = this.uponTouchStart.bind(this);
	this.uponTouchCancelClosure = this.uponTouchCancel.bind(this);
	this.uponTouchEndClosure = this.uponTouchEnd.bind(this);
	this.uponTouchDragClosure = this.uponTouchDrag.bind(this);
	
	this.uponMouseDragStartClosure = this.uponDragStart.bind(this);
	this.uponMouseOutClosure = this.uponMouseOut.bind(this);
	this.uponMouseDragClosure = this.uponDrag.bind(this);
	this.uponMouseDropClosure = this.uponDrop.bind(this);
};


DragResize.prototype.init = function(o,oRoot) {

	if(o == null) return;
	/* get the child element to drag.  It will be the "input image" element.
	 * We will use this child (called dragImage) to attach the touch and mouse events
	 */
	this.dragImage = this.fixDragImage(o);
	this.obj = o;
	this.frame = oRoot.getElementsByTagName("iframe")[0];
	
	/*  When we close the chat interface, we don't actually destroy */
	/*  the div/img/input nodes that we create on initialization. */
	/*  So, we check the [INSTANCE_LABEL] property here as a flag */
	/*  to see if we've already bound the event handlers.  If we */
	/*  have, then we MUST NOT BIND THEM AGAIN, or we get really */
	/*  strange bugs. */
	if(o[DragResize.INSTANCE_LABEL] != null) 
		log("o already has property for " + DragResize.INSTANCE_LABEL + ": " + o[DragResize.INSTANCE_LABEL]); 
	else {
		o[DragResize.INSTANCE_LABEL] = this;
		oRoot[DragResize.INSTANCE_LABEL] = this;
		
		/* trace("class name is " + this.className); */
		this.root = oRoot && oRoot != null?oRoot:o;
		
		this.bindClosures();
		
		/*  Bind initial event handlers */
		if(this.isSupported("touchstart")) {
			/* trace("binding touchstart to " + (untyped o.tagName) + "#" + (untyped o.id)); */
			this.obj[DragResize.INSTANCE_LABEL] = this;
			this._attachEventListener(this.dragImage,"touchstart",this.uponTouchStartClosure);
		}
		if(this.isSupported("mousedown")) this._attachEventListener(this.dragImage,"mousedown",this.uponMouseDragStartClosure);
	}
};

DragResize.prototype.fixDragImage = function(element) {
	/** @type {Node} */
	var par;
	/** @type {number} */
	var _g1 = 0;
	/** @type {number} */
	var _g;
	if(element.nodeName.toUpperCase() == "IMG") {
		/* trace("    binding to IMG"); */
		par = element.parentNode;
		/** @type {Element} */ 
		var div = document.createElement("DIV");
		div.id = element.id;
		div.style.cssText = "background-color:#007700; opacity:0.4; " + String(element.style.cssText);
		div.title = element.title;
		par.insertBefore(div,element);
		
		/* Now fix the image so it fills the entire div */
		element.style.height = element.style.width = "100%";
		element.style.position = "absolute";
		element.style.top = element.style.left = "0px";
		/* Make the image id different from div */
		element.id = div.id + "_image";
		par.removeChild(element);
		return div;
	} else if(element.nodeName.toUpperCase() == "DIV") {
		/* We want to replace the "img" tag with "input image"
		 * So we:
		 * 1) Get list of all images.
		 * 2) Get the image that is a direct child of the parent div
		 * 		This is important because "getElementsByTagName gets all decendents, not just children
		 * 3) replace image with the input image
		 */
		/** @type {NodeList} */
		var images = element.getElementsByTagName("IMG");
		if (images.length > 0) {
			/** @type {Node} */
			var image = null;
			_g1 = 0;
			_g = images.length;
			while (_g1 < _g) {
				/** @type {number} */
				var i1 = _g1++;
				if (images[i1].parentNode == element) {
					image = images[i1];
					break;
				}
			}
			if (image != null) {
				par = image.parentNode;
				if (par == element) {
					/** @type {Element} */
					var dragSafe = document.createElement("INPUT");
					dragSafe.type = "image";
					if(image.src == null || image.src == "") dragSafe.src = MessageWindow.clearImage;/* Make sure that the source has the clear image in it */ else dragSafe.src = image.src;/* Make sure that the source has the clear image in it */
					dragSafe.style.cssText = String(element.style.cssText) + "; top:0px; left:0px; height: 100%; width: 100%;display:block;padding:0;margin:0;";
					dragSafe.className = "tcChat";
					dragSafe.name = "DragSafe";/* We make the name "DragSafe" so that we can find it during debug */
					addAriaToDrag(dragSafe);
					par.replaceChild(dragSafe,image);
					return dragSafe;
				}
			}
		}
		
		/* Now find the first input element that belongs to the DIV as a direct decendant (child)
		 * and we
		 */
		/** @type {Element} */
		var inputEl = null;
		/** @type {NodeList} */
		var inputs = element.getElementsByTagName("INPUT");
		if (inputs.length > 0) {
			_g1 = 0;
			_g = inputs.length;
			while (_g1 < _g) {
				/** @type {number} */
				var i = _g1++;
				if (inputs[i].parentNode == element) {
					inputEl = inputs[i];
					break;
				}
			}
			if (inputEl != null && inputEl.name != "DragSafe") {
				inputEl.name = "DragSafe";
				/* We make the name "DragSafe" so that we can find it during debug */
				inputEl.style.cssText =  " cursor: move; top:0px; left:0px; height: 100%; width: 100%;display: block;padding:0;margin:0;";
				inputEl.className = "tcChat";
				addAriaToDrag(inputEl);
			}
		}
		/* According issue RTDEV-7155 input elements on the client's page may be changed.
		 * Therefore we need to use parent element instead input element to attach handler.
	     * Before this was returning an inputEl.
		 */
	}

	/**
	 * Its a utility function created to remove code duplicity
	 * @param el
	 */
	function addAriaToDrag(el) {
		el.setAttribute("aria-hidden", "true");
		el.setAttribute("alt", "");
		el.setAttribute("tabindex", "-1");
	}
	return element;
};


DragResize.prototype.isLeftClick = function(e) {
	/** @type {Event} */ 
	var ev = !!e?e:window.event;
	/** @type {number} */ 
	var mouseButtonState = 1;
	/*Assume Left button */
	if(window.navigator.appName == "Netscape") mouseButtonState = e.which; else mouseButtonState = window.parent.event.button;
	if(ev.type.indexOf("touch") == 0) return true;
	return mouseButtonState == 1;
};


DragResize.prototype.fireDone = function() {
	this.whenDone();
};


DragResize.prototype.fireDoneState = function() {
	DragResize.instance = this;
	window.setTimeout(DragResize.WhenDone,1);
};


DragResize.prototype.removeTouchEvents = function() {
	this._attachEventListener(this.dragImage,"mousedown",this.uponMouseDragStartClosure);/*  Restore mouse handler*/
	this._removeEventListener(DragResize.doc,"touchcancel",this.uponTouchCancelClosure);/*  Remove touch handlers.*/
	this._removeEventListener(DragResize.doc,"touchend",this.uponTouchEndClosure);
	this._removeEventListener(DragResize.doc,"touchmove",this.uponTouchDragClosure);
};


DragResize.prototype.removeMouseEvents = function() {
	this._attachEventListener(this.dragImage,"touchstart",this.uponTouchStartClosure);/*  Restore touch handler*/
	this._removeEventListener(DragResize.doc,"mouseout",this.uponMouseOutClosure);/*  Remove mouse hanlders.*/
	this._removeEventListener(DragResize.doc,"mousemove",this.uponMouseDragClosure);
	this._removeEventListener(DragResize.doc,"mouseup",this.uponMouseDropClosure);
};

DragResize.prototype.addTouchEvents = function() {
	this._removeEventListener(this.dragImage,"mousedown",this.uponMouseDragStartClosure);/*  Temp. remove the mouse handler*/
	this._attachEventListener(DragResize.doc,"touchcancel",this.uponTouchCancelClosure);/*  Bind touch handlers*/
	this._attachEventListener(DragResize.doc,"touchend",this.uponTouchEndClosure);
	this._attachEventListener(DragResize.doc,"touchmove",this.uponTouchDragClosure);
};

DragResize.prototype.addMouseEvents = function() {
	this._removeEventListener(this.obj,"touchstart",this.uponTouchStartClosure);/*  Temp. remove the touch handler.*/
	this._attachEventListener(DragResize.doc,"mouseout",this.uponMouseOutClosure);/*  Bind mouse handlers.*/
	this._attachEventListener(DragResize.doc,"mousemove",this.uponMouseDragClosure);
	this._attachEventListener(DragResize.doc,"mouseup",this.uponMouseDropClosure);
};


DragResize.prototype.removeEvents = function() {
	this.removeMouseEvents();
	/* 	removeTouchEvents(); */
	this.fireDoneState();
};


DragResize.prototype.uponTouchCancel = function(e) {
	/** @type {Event} */ 
	var ev = !!e?e:window.event;
	if(ev.preventDefault != null) ev.preventDefault();
	return false;
};

DragResize.prototype.uponTouchEnd = function(e) {
	try {
		/** @type {Event} */
		var ev = !!e?e:window.event;
		if(ev.preventDefault != null) ev.preventDefault();
		this.touch = this.getTouchByIdentifer(ev);
		if(this.touch == null) return false;
		//this.restoreStyle();
		/** @type {Object} */
		var pCur = {X: this.touch.pageX - this.touchOffsetX, Y: this.touch.pageY - this.touchOffsetY};
		
		this.repositionTouch(pCur);
		this.removeTouchEvents();
		this.done();
	} catch( e1 ) {
		log("ERROR: uponTouchEnd: " + e1);
	}
	return false;
};


DragResize.prototype.getTouchByIdentifer = function(ev) {
	try {
		/** @type {Array} */ 
		var touchList = ev.changedTouches;
		if(touchList == null) return null;
		if(this.touchIdentifier == DragResize.TOUCH_IDENTIFER_UNUSED) return null;
		if(touchList.identifiedTouch == null) {
			/*   identifiedTouch not implemented in safari even though in W3C specification */
			/** @type {number} */
			var _g1 = 0;
			/** @type {number} */ 
			var _g = touchList.length;
			while(_g1 < _g) {
				/** @type {number} */
				var i1 = _g1++;
				if(touchList[i1].identifier == this.touchIdentifier) return touchList[i1];
			}
			return null;
		} else return touchList.identifiedTouch(this.touchIdentifier);
	} catch( e ) {
		
		log("ERROR: getTouchByIdentifer: " + e);
	}
	return null;
};

DragResize.prototype.done = function() {
	this.touchIdentifier = DragResize.TOUCH_IDENTIFER_UNUSED;
	window.setTimeout(this.whenDone.bind(this),1);
};


DragResize.prototype.uponDrop = function(e) {
	/** @type {Event} */ 
	var ev = !!e?e:window.event;
	if(ev.preventDefault != null) ev.preventDefault();

	/** @type {Object} */
	var pCur = this.getPosition(ev);
	this.removeEvents();
	this.done();
	this.frame.style.pointerEvents = "auto";
	return this.reposition(pCur);
};

DragResize.prototype.uponMouseOut = function(e) {
	/** @type {Event} */ 
	var ev = !!e?e:window.event;
	if(ev.preventDefault != null) ev.preventDefault();

	var pMin = this.getDefaultMin();
	var pMax = this.getDefaultMax();
	
	/** @type {Object} */ 
	var pCur = this.getPosition(ev);
	/** @type {boolean} */
	var outOfArea = false;
	/** @type {Object} */
	
	



	if(pCur.Y < pMin.Y) {
		pCur.Y = pMin.Y;
		outOfArea = true;
	}
	if(pCur.X < pMin.X) {
		pCur.X = pMin.X;
		outOfArea = true;
	}
	if(pCur.Y >= pMax.Y+this.root.offsetHeight) {
		pCur.Y = pMax.Y+this.root.offsetHeight;
		outOfArea = true;
	}
	if(pCur.X >= pMax.X + this.root.offsetWidth) {
		pCur.X = pMax.X + this.root.offsetWidth;
		outOfArea = true;
	}
	if(outOfArea) {
		//console.log("insid2")
		/* trace ("X,Y = " + pCur.X + "," + pCur.Y); */
		this.removeEvents();
		//this.restoreStyle();
		this.reposition(pCur);
		this.fireDoneState();
		this.frame.style.pointerEvents = "auto";
		return false;
	}
	/* trace("unexpected out of area X,Y = " + pCur.X + "," + pCur.Y); */
	return this.uponDrag(ev);
};

DragResize.prototype.getScreenMax = function() {
	return { X : ScrollMonitor.getScrollWidth() - 5, Y :  ScrollMonitor.getScrollHeight() - 5};
};


DragResize.prototype.repositionTouch = function(pCur) {
	try {
		/* If no movement since the last check, then return */
		if(this.pLast != null && pCur.X == this.pLast.X && pCur.Y == this.pLast.Y) return false;
		/** @type {number} */ 
		var top;
		/** @type {number} */ 
		var left;
		
		left = pCur.X;
		if(pCur.X != this.pLast.X && left >= this.pMin.X && left < this.pMax.X) this.setLeft(left); else /* if x-axis movement in the valid area then reposition Left */
		if(left >= this.pMax.X) this.setLeft(left = this.pMax.X); else /* if x-axis movement more than maximum, then use maximum */
		if(left < this.pMin.X) this.setLeft(left = this.pMin.X);
		/* if x-axis movement less than minimum, then use minimum */
		
		top = pCur.Y;
		if(pCur.Y != this.pLast.Y && top >= this.pMin.Y && top < this.pMax.Y) this.setTop(top); else /* if y-axis movement in the valid area then reposition Top */
		if(top >= this.pMax.Y) this.setTop(top = this.pMax.Y); else /* if y-axis movement more than maximum, then use maximum */
		if(top < this.pMin.Y) this.setTop(top = this.pMin.Y);
		/* if y-axis movement less than minimum, then use minimum */
		
		
		this.pDraggerNow = { X : left, Y : top};
		
		this.pLast = pCur;
	} catch( e ) {
		log("ERROR: repositionTouch: " + e);
	}
	return false;
};


DragResize.prototype.reposition = function(pCur) {

    
	/** @type {number} */
	var top = pCur.Y - this.deltaY;
	/** @type {number} */ 
	var left = pCur.X - this.deltaX;

	if (left >= this.pMin.X && left < this.pMax.X) {
		this.pDraggerNow.X = left;
	} else if (left >= this.pMax.X) {
		this.pDraggerNow.X = this.pMax.X;
	} else if (left < this.pMin.X) {
		this.pDraggerNow.X = this.pMin.X;
	}
	if (top >= this.pMin.Y && top < this.pMax.Y) {
		this.pDraggerNow.Y = top;
	} else if (top >= this.pMax.Y) {
		this.pDraggerNow.Y = this.pMax.Y;
	} else if (top < this.pMin.Y) {
		this.pDraggerNow.Y = this.pMin.Y;
	}
	
	// after check and fix coordinates we set this coordinates for chat,
	// and also set current position as last.
	this.setTop(this.pDraggerNow.Y);
	this.setLeft(this.pDraggerNow.X);
	this.pLast = pCur;
	return false;
};


DragResize.prototype.uponTouchDrag = function(e) {
	/** @type {Event} */ 
	var ev = !!e?e:window.event;
	if(ev.preventDefault != null) ev.preventDefault();
	try {
		/* trace("uponTouchDrag"); */
		this.touch = this.getTouchByIdentifer(ev);
		if(this.touch == null) return false;
		/** @type {Object} */
		var pCur = {X: this.touch.pageX - this.touchOffsetX, Y: this.touch.pageY - this.touchOffsetY};
		
		/* trace("" + this.className + " { X:" + touch.pageX + ",Y:" + touch.pageY + " } " + " offset ("+this.touchOffsetX+","+this.touchOffsetY+") "); */
		
		this.repositionTouch(pCur);
	} catch( e1 ) {
		
		log("uponTouchDrag ERROR: " + e1);
	}
	return false;
};

DragResize.prototype.uponDrag = function(e) {
	/** @type {Event} */ 
	var ev = !!e?e:window.event;
	if(!!this.obj.dragging) return false;
	this.obj.dragging = true;
	if(ev.preventDefault != null) ev.preventDefault();
	/** @type {Object} */ 
	var pCur = this.getPosition(ev);
	/* trace("uponDrag: ("+pCur.X+","+pCur.Y+") "+mouseDown+" "); */
	if(this.timeout) {
		window.cancelAnimationFrame(this.timeout);
	}
	this.timeout = window.requestAnimationFrame(function(){
		this.reposition(pCur);
	}.bind(this));
	
	this.obj.dragging = false;
	return false;
};


DragResize.prototype.uponTouchStart = function(e) {
	/** @type {Event} */ 
	var ev = !!e?e:window.event;
	if(ev.preventDefault != null) ev.preventDefault();

	/** @type {Element} */
	var o = this.obj;
	
	/* trace("    Setting pStart"); */
	//this.pStart = { X : parseInt(this.root.style.left), Y : parseInt(this.root.style.top)};

	/** @type {CSSStyleDeclaration} */
	var style = o.style;
	
	if(this.touchIdentifier != DragResize.TOUCH_IDENTIFER_UNUSED) return false;
	this.touch = ev.changedTouches[0];
	//this.touchOffsetX = Math.round(this.touch.pageX) - parseInt(style.left);
	//this.touchOffsetY = Math.round(this.touch.pageY) - parseInt(style.top);
	this.touchOffsetX = Math.round(this.touch.pageX) - parseInt(this.root.offsetLeft);
	this.touchOffsetY = Math.round(this.touch.pageY) - parseInt(this.root.offsetTop);
	this.touchIdentifier = this.touch.identifier;
	
	this.pMin = this.getDefaultMin();
	this.pMax = this.getDefaultMax();
	
	//this.saveStyle();
	o.style.cursor = this.cursor;
	
	
	this.addTouchEvents();
	/*  Bind the closuers as event handlers. */
	
	//this.setDragBorder();
	this.pLast = { X : this.touch.pageX - this.clickOffsetX, Y : this.touch.pageY - this.clickOffsetY};
	return false;
};


DragResize.prototype.uponDragStart = function(e) {
	/** @type {Event} */
	var ev = !!e ? e : window.event;
	if(ev.preventDefault != null) ev.preventDefault();

	/** @type {Element} */
	var o = this.obj;
	if(!this.isLeftClick(ev)) return false;
	//this.pStart = { X : parseInt(this.root.offsetLeft), Y : parseInt(this.root.offsetTop)};
	
	//this.pDraggerStart = { X : parseInt(o.style["left"]), Y : parseInt(o.style["top"])};
	//this.draggerHeight = parseInt(o.style.height);
	//this.draggerWidth = parseInt(o.style.width);
	
	this.pDraggerNow = { X : parseInt(this.root.offsetLeft), Y :  parseInt(this.root.offsetTop)};
	this.pLast = this.getPosition(ev);
	
	this.deltaX = this.pLast.X - this.pDraggerNow.X;
	this.deltaY = this.pLast.Y - this.pDraggerNow.Y;
	
	this.pMin = this.getDefaultMin();
	this.pMax = this.getDefaultMax();

	
	//this.saveStyle();
	o.style.cursor = this.cursor;
	//this.setDragBorder();
	DragResize.instance = this;
	this.frame.style.pointerEvents = "none";
	this.addMouseEvents();
	
	return false;
};


DragResize.prototype.setDragBorder = function() {
};

DragResize.prototype.getDefaultMax = function() {
	return { X : 10000, Y : 10000};
};


DragResize.prototype.getDefaultMin = function() {
	return { X : 0, Y : 0};
};


DragResize.prototype.setLeft = function(top) {
	log("setLeft override failed");
};

DragResize.prototype.setTop = function(top) {
	log("setTop override failed");
};

DragResize.prototype.whenDone = function() {
};

DragResize.prototype.isSupported = function(eventType) {
	return "on"+eventType in document.documentElement;
};

DragResize.prototype.getPositionIE = function(e) {
	return { X : window.parent.event.clientX, Y : window.parent.event.clientY};
};


DragResize.prototype.getPositionGecko = function(e) {
	return { X : e.clientX, Y : e.clientY};
};

DragResize.prototype.getPosition = function(e) {
	return { X : e.clientX, Y : e.clientY};
};

DragResize.prototype.clear = function() {
	this.root[DragResize.INSTANCE_LABEL] = null;
	this.obj[DragResize.INSTANCE_LABEL] = null;
	this._removeEventListener(this.obj,"touchstart",this.uponTouchStartClosure);
	this._removeEventListener(this.dragImage,"mousedown",this.uponMouseDragStartClosure);

};

/** @private @type {null} */
DragResize.prototype.uponMouseDropClosure = null;
/** @private @type {null} */
DragResize.prototype.uponMouseDragClosure = null;
/** @private @type {null} */
DragResize.prototype.uponMouseOutClosure = null;
/** @private @type {null} */
DragResize.prototype.uponMouseDragStartClosure = null;
/** @private @type {null} */
DragResize.prototype.uponTouchDragClosure = null;
/** @private @type {null} */
DragResize.prototype.uponTouchEndClosure = null;
/** @private @type {null} */
DragResize.prototype.uponTouchCancelClosure = null;
/** @private @type {null} */
DragResize.prototype.uponTouchStartClosure = null;
/** @private @type {number} */
DragResize.prototype.deltaY = null;
/** @private @type {number} */
DragResize.prototype.deltaX = null;
/** @private @type {null} */
DragResize.prototype.pMax = null;
/** @private @type {null} */
DragResize.prototype.pMin = null;
/** @private @type {number} */
DragResize.prototype.rootWidth = null;
/** @private @type {number} */
DragResize.prototype.rootHeight = null;
/** @private @type {number} */
DragResize.prototype.draggerHeight = null;
/** @private @type {number} */
DragResize.prototype.draggerWidth = null;
/** @private @type {null} */
DragResize.prototype.pDraggerNow = null;
/** @private @type {null} */
DragResize.prototype.pDraggerStart = null;
/** @private @type {null} */
DragResize.prototype.pStart = null;
/** @private @type {null} */
DragResize.prototype.pLast = null;
/** @private @type {number} */
DragResize.prototype.touchIdentifier = null;
/** @private @type {number} */
DragResize.prototype.touchOffsetY = null;
/** @private @type {number} */
DragResize.prototype.touchOffsetX = null;
/** @private @type {number} */
DragResize.prototype.clickOffsetY = null;
/** @private @type {number} */
DragResize.prototype.clickOffsetX = null;
/** @private @type {null} */
DragResize.prototype.touch = null;
/** @private @type {string} */
DragResize.prototype.styleSaved = null;
/** @private @type {string} */
DragResize.prototype.cursor = null;
/** @private @type {js.HtmlDom} */
DragResize.prototype.root = null;
/** @private @type {js.HtmlDom} */
DragResize.prototype.dragImage = null;
/** @private @type {js.HtmlDom} */
DragResize.prototype.obj = null;

DragResize.TOUCH_IDENTIFER_UNUSED = -1;

/** @private @type {string} */
DragResize.INSTANCE_LABEL = "instDragResize";

/** @private @type {js.HtmlDom} */
DragResize.doc = window.parent.document;

/** @type {null} */
DragResize.instance = null;

/** @type {string} */
DragResize.DEFAULT_BORDER_COLOR = "SlateGray";


var Move = function(dragMode) {
	DragResize.call(this);
	this.className = "Move";
	this.cursor = "move";
	this.dm = dragMode;
};

for(var k in DragResize.prototype ) Move.prototype[k] = DragResize.prototype[k];

Move.setDragable = function(dragMode) {
	
	/** @type {com.inq.stage.Move} */ 
	var instance = new Move(dragMode);
	var pDoc = window.parent.document;
	/** @type {Element} */ 
	var cntr = pDoc.getElementById(config.frameID);
	/** @type {Element} */ 
	var dragHandleElem = pDoc.getElementById("nuanTitleBar");
	instance.init(dragHandleElem,cntr);
};


Move.prototype.setTop = function(top) {
	/** @type {Element} */
	 var o = this.root;
	o.style.top = top + "px";
};


Move.prototype.setLeft = function(left) {
	this.root.style.left = left + "px";
};
/*
Move.prototype.setDragBorder = function() {
	/** @type {number} * / 
	var rootHeight = parseInt(this.root.style.height);
	/** @type {number} * / 
	var rootWidth = parseInt(this.root.style.width);
	/** @type {number} * / 
	var borderWidth = 7;
	this.obj.style.cursor = this.cursor;
	this.obj.style.borderStyle = "solid";
	this.obj.style.borderWidth = borderWidth + "px";
	this.obj.style.borderColor = DragResize.DEFAULT_BORDER_COLOR;
	
	this.obj.style.height = rootHeight - borderWidth + "px";
	this.obj.style.width = rootWidth - borderWidth + "px";
};
*/

Move.prototype.whenDone = function() {
	this.root.style.left = String(this.pDraggerNow.X) + "px";
	this.root.style.top = String(this.pDraggerNow.Y) + "px";
	/** @type {Object} */ 
	var position = { X : this.pDraggerNow.X, Y : this.pDraggerNow.Y};
	messageWindow.moveStage(position.X,position.Y);
};


Move.prototype.getDefaultMax = function() {
	/** @type {number} */ 
	var width = parseInt(window.getComputedStyle(this.root).width);
	/** @type {number} */ 
	var height = parseInt(window.getComputedStyle(this.root).height);
	
	return { X : ScrollMonitor.getScrollWidth() - width, Y : ScrollMonitor.getScrollHeight() - height - (this.dm == "horizontal"? parseInt(this.root.style.bottom): 0)};
};


Move.prototype.getDefaultMin = function() {
	var height = parseInt(window.getComputedStyle(this.root).height);
	return { X : 0, Y : this.dm == "horizontal"? ScrollMonitor.getScrollHeight() - parseInt(this.root.style.bottom) - height :0};
};



	var activeWindow = null;
	var c2cmgr = new C2CMgr();



	return {

		/**
		 * Fired when Bootstrap is initialzied
		 * @typedef {function():void} InitCB
		 * @callback
		 */

		 /**
		 * Fired when Bootstrap is initialzied
		 * @function
		 * @name initMethod

		 * @param {string} dataCenter -  name of the data center that is provisoned for the client 
		 * @param {string} dataCenter -  unique tagserver name given for the client
		 * @param {InitCB} callbac -  callback that gets invoked when SDK is initialized 
		 */

		/**
		* @property {initMethod} NuanMessaging.initializeMessagingSDK
		*/
		initializeMessagingSDK : function(dataCenter, tagServerName, vendorUUID, callback) {
			//urlConfigObj.clientID = clientID;
			//urlConfigObj.clientSecret = clientSecret;
			urlConfigObj.dataCenter = dataCenter;
			urlConfigObj.tagServerName = tagServerName;
			urlConfigObj.vendorUUID = vendorUUID;

			if(checkArity(urlConfigObj,"config")) {
				log("Failed to initialize SDK, invalid or missing parameters.");
				return;
			}

			config.setPageData("pageUrl",doc.URL);	
			config.setPageData("inqSiteID",window.inqSiteID);	
			config.setPageData("inqSalesProducts",window.inqSalesProducts);	
			config.setPageData("inqSalesQuantities",window.inqSalesQuantities);	
			config.setPageData("inqSalesProductTypes",window.inqSalesProductTypes);	
			config.setPageData("inqSalesProducts2",window.inqSalesProducts2);	
			config.setPageData("inqSalesQuantities2",window.inqSalesQuantities2);	
			config.setPageData("inqSalesPrices2",window.inqSalesPrices2);	
			config.setPageData("inqOrderType",window.inqOrderType);	

			config.registerForMessagingEvents(config.Events.ON_C2C_READY, c2cmgr.render.bind(c2cmgr));
			config.registerForMessagingEvents(config.Events.ON_C2C_STATE_CHANGED, function(data) {
				if(data) {
					var image = c2cmgr.IMAGETYPES[data.newState];
					if(image){
						c2cmgr.renderState(image,data);
					}
				}
			});

			config.registerForMessagingEvents(config.Events.ON_C2C_DISPLAYED, function(data){
				if (!isNullOrUndefined(C2C.VirtualKeyboardOpenCloseHandler)) {
					C2C.VirtualKeyboardOpenCloseHandler.addListener(data);
				}
			});

			config.registerForMessagingEvents(config.Events.ON_C2C_CLICKED, function(data) {
				if(data) {
					C2CMgr.lastusedC2CId = data.pageElementID;
					C2CMgr.c2cBtnId = null;
					if (!isNullOrUndefined(C2C.VirtualKeyboardOpenCloseHandler)) {
						C2C.VirtualKeyboardOpenCloseHandler.removeListener(data);
					}
				}
			});

			config.registerForMessagingEvents(config.Events.ON_CHAT_CLOSED, function(){
				c2cmgr.clear();
				if(messageWindow) {
					messageWindow.clear();
				}
				if(activeWindow) {
					activeWindow.removeListener();
				}

			});
			config.registerForMessagingEvents(config.Events.ON_CHAT_LAUNCHED, c2cmgr.setDisabled.bind(c2cmgr));

			config.registerForMessagingEvents(config.Events.ON_CHAT_SHOWN , function() {
				activeWindow = new ActiveWindow();	
			});
			if(callback) {
				callback();
			}
		},
		/**
		*returns the Bootstrap config object
		* @property {function():config} NuanMessaging.getAndSetSDKConfig	
		*/
		getAndSetSDKConfig: function() {
			return config;
		},
		/**
		*inject the sandboxed iframe and init loading of nuance framework within it
		* @property {function(string):config} NuanMessaging.loadChatAssets	
		*/
		loadChatAssets:function(testReady) {
			if (doc.getElementById(config.frameID)) {
				return;
			}

			if(!config.siteID) {
				log("site ID is found in config object.");
				return;
			}

			if(testReady) {
				testDomReady();
			} else {
				setDomReadyTimeout();
			}

		},
		/**
		 * @function
		 * @name addCustomJS
		 * @param {string} funcName  - name of the function
		 * @param {function} funcRef -  function reference that will be called when there is a targetting
		 */

		/**
		*add references to javscript function can be invoked from Nuance Targetting engine
		* @property {addCustomJS} NuanMessaging.addCustomJavascript	
		*/
		addCustomJavascript:function(funcName, funcRef) {
			funcMap[funcName] = funcRef;
		},
		/**
		 * @typedef {object<string:any>} SDKAPI
		 */
		 /** API for various chat operation
		 * @property {SDKAPI} NuanMessaging.SDKAPI
		 */
		SDKAPI: {
			/** Allowing web page to launch a chat by passing a rule id
			 * @property {function(number):void} SDKAPI.launchChatByRuleID
			 */
			launchChatByRuleID : function(ruleID) {
				fireMesageToBridge(new Message("LAUNCH_CHAT_RULEID",ruleID));
			},
			/** Allowing web page to launch a chat by passing a rule name
			 * @property {function(string):void} SDKAPI.launchChatNowByRuleName
			 */
			launchChatNowByRuleName : function(ruleName) {
				fireMesageToBridge(new Message("LAUNCH_CHAT_RULENAME",ruleName));
			},
			/** Allowing web page to suppress the chat for this session
			 * @property {function():void} SDKAPI.suppressChatForSession
			 */
			suppressChatForSession:function() {
				fireMesageToBridge(new Message("BLOCK_CHAT_SESSION"));
			},
			/** Allowing web page to reinit the chat framework in a single page design
			 * @property {function(number, object):void} SDKAPI.reInitChat
			 */
			reInitChat:function(pageId,data) {
				c2cmgr.clear();
				for (var i = domListeners.length; i--;) {
					detachListener(domListeners[i].target, domListeners[i].type, domListeners[i].listener);
				}
				domListeners = [];
				fireMesageToBridge(new Message("REINIT_CHAT",{"pageID":pageId,"data":data}));
			},
			/**		
			 * @function 	
			 * @name customEvent
			 * @param {string} eventName  - name of the event
			 * @param {object|string} eventData -  data associated with the event
			 * @param {object} pageData -  page data that is needed to be passed to nuance sandboxed iframe
			 */
			/** Allowing web page to fire a custom event so that Nuance targetting can act on it
			 * @property {customEvent} SDKAPI.fireCustomEvent
			 */
			fireCustomEvent:function(eventName, eventData, pageData) {
				fireMesageToBridge(new Message("CUSTOM_EVENT",{"eventName":eventName,"data":eventData},pageData));
			},
			/**	
			 * @function	 	
			 * @name automatonMesage
			 * @param {string} [msgType]  - type of the message which is an optional parameter, value currently available is "datapass"
			 * @param {string|object} message -  data associated with this request, object for datapass and text for others
			 */
			/** Allowing web page to send a virtual agent message 
			 * @property {automatonMesage} SDKAPI.sendAutomatonMessage
			 */
			sendAutomatonMessage:function(msgType, message) {
				fireMesageToBridge(new Message("SEND_AUTOMATON_MSG",{"msgType":msgType,"msg":message}));
			},

			/**
			 * Triggers focus to the chat "ready" element (default is: footerArea.input of chat)
			 * Note: works only for implemented "ready_focus" elements.
			 * 
			 * @param {String} focusTargetName - id name of the target element to focus
			 */
			sendReadyFocus: function(focusTargetName){
				fireMesageToBridge(new Message("READY_FOCUS", focusTargetName));
			},

			/** Allowing web page to close an opened chat 
			 * @property {function():void} SDKAPI.closeChat
			 */
			closeChat:function() {
				fireMesageToBridge(new Message("CLOSE_CHAT"));
				dynamicCBQueue = [];
			},

			/**
			 * when chatid's retrieved from Sandboxed iframe
			 * @typedef {function(string):void} chatIDCB
			 * @callback
			 * @param {string} chatid
			 */
			/** Allowing web page to get the current engagement ID
			 * @property {function(chatIDCB):void} SDKAPI.getChatID
			 */
			getChatID:function(cb) {
				var msg = new Message("GET_CHAT_ID");
				msg.setCallback(cb);
				dynamicCBQueue.push(msg);
				fireMesageToBridge(msg);
				
			},
			/**
			 * when framework initialization state is retrieved from Sandboxed iframe
			 * @typedef {function(boolean):void} chatFrameworkCB
			 * @callback
			 * @param {boolean} inited
			 */
			/** Allowing web page to get initialization state
			 * @property {function(chatFrameworkCB):void} SDKAPI.isFrameworkInitialized
			 */
			isFrameworkInitialized:function(cb) {
				var msg = new Message("IS_INITIALIZED");
				msg.setCallback(cb);
				dynamicCBQueue.push(msg);
				fireMesageToBridge(msg);
				
			},
			/**
			 * when framework finds the value of the asked variable
			 * @typedef {function(string):void} dynamicVarCB
			 * @callback
			 * @param {string} inited
			 */
			/** Allowing web page to get values of certain variables published by nuance targetting
			 * @property {function(string,dynamicVarCB):void} SDKAPI.getBRPublishedVariableRef
			 */	
			getBRPublishedVariableRef:function(apiKey,cb) {
				var msg = new Message("DYNAMIC_API_REF",apiKey);
				msg.setCallback(cb);
				dynamicCBQueue.push(msg);
				fireMesageToBridge(msg);
			},
			/** Allowing web page to publish new page data to Nuance sandbox iframe
			 * @property {function(object):void} SDKAPI.publishNewPageData
			 */	
			publishNewPageData:function(dataObj) {
				fireMesageToBridge(new Message("NEW_PAGE_DATA","",dataObj));
			},
			/** When c2c button is restored from minimized state
			 * @property {function():void} SDKAPI.onRestoredClicked
			 */	
			onRestoredClicked:function() {
				fireMesageToBridge(new Message("FRAME_RESTORED"));
				if(messageWindow){
					messageWindow.setVisible(true);
				}
				if(c2cmgr) {
					c2cmgr.setDisabled();
				} 

			},
			ciMinimize:function() {
				if(messageWindow && !messageWindow.isMinimized()) {
					fireMesageToBridge(new Message("MINIMIZE_FRAME"));	
				}
			},
			/**
			 * Object which represent an image resource
			 * @typedef {Object<string,any>} ImageO
			 * @property {string} ImageO.imgname - name of the image which is stored under nuance theme folder
			 * @property {string} ImageO.imgsrc - url pointing to an image file
			 */

			/** When webpage wants to update the chat window logo during an active engagement
			 * @property {function(ImageO):void} SDKAPI.updateLogo
			 */	
			updateLogo:function(logo) {
				if(Object(logo) === logo) {
					fireMesageToBridge(new Message("UPDATE_LOGO",logo));
				} else {
					logError("updateLogo expects an object, with 'imgname' or 'imgsrc' properties");
				}
			},
			/** When webpage wants to update the chat window title during an active engagement
			 * @property {function(string):void} SDKAPI.updateTitle
			 */	
			updateTitle:function(title) {
				if(title) {
					fireMesageToBridge(new Message("UPDATE_TITLE",title));
				}
			},
			/** When webpage wants to start an engagement automatically after chat is displayed, passed string will be send a client communication outcome
			 * @property {function(string):void} SDKAPI.autoEngage
			 */	
			autoEngage:function(autoText) {
				fireMesageToBridge(new Message("AUTO_ENGAGE", autoText));
			}
		},
		getC2CMgr:function() {
			return c2cmgr;
		},
		/**
		 * @typedef {object<string:any>} CIAPI
		 */
		 /** Customer Interface API Definition 
		 * @property {CIAPI} NuanMessaging.CIAPI
		 */
		CIAPI:{
			/**
			 * @typedef {Object<string:string>} Status			
			 * @property {string} Status.state - show or missed
			 */
			/**
			 * Fires upon receiving the response from backend regarding the request for requesting an engagement
			 * @typedef {function(Status):void} c2cClickedCB
			 * @callback
			 * @param {Status} status
			 */
			 /**
			 * @function
			 * @name onC2cClicked
			 * @param {number} c2cId - id of the c2c
			 * @param {c2cClickedCB} callback - callback that is fired upon receving a response for requesting an engagement
			 */
			/** Allowing client Javascript to let Nuance Framework know that c2c button is clicked
			 * @property {onC2cClicked} CIAPI.onC2CClicked
			 */
			onC2CClicked:function(idx,callback) {
				if(arguments.length!=2 && disableC2Crender && !bootstrapC2cInstance) {
					logError("Missing arguments, needs c2cid and a callback to continue");
					return;
				}
				var msg = new Message("C2C_ACTION",idx);
				msg.setCallback(c2cmgr.c2cCallbackHandler.bind(c2cmgr, callback));
			    dynamicCBQueue.push(msg);
				
				fireMesageToBridge(msg);
			},

			/**
			 * @typedef {Object<string:any>} displayedParams			
			 * @property {function(Array.<Object>)} displayedParams.previousMessagesCb - This callback is invoked with all the previous chat messages upon user reloading the page or navigating to a new page.
			 * @property {function} displayedParams.disconnectCb - This callback will be invoked when Nuance SDK detects a network problem connecting to the chat server.
			 * @property {function} displayedParams.reconnectCb - This callback is invoked to let client JavaScript know when SDK reestablish the connection.
			 * @property {function} displayedParams.failedCb - This callback is invoked to let client JS know that connection with server is permanently failed.
			 * @property {Array.<string>} displayedParams.openerScripts - Opener messages that is presented to the user, parameter should be an array of strings.
			 * @property {string} displayedParams.defaultAgentAlias - Agent Name that is displayed for opener script
			 * @property {string} displayedParams.customerName - Name of the customer to be displayed to agent
			 */
			/** Allowing client CI to register with nuance framework for various callbacks
			 * @property {function(displayedParams):void} CIAPI.chatDisplayed
			 */
			chatDisplayed:function(displayedParams) {
				if(typeof  displayedParams != "object"){ return; }
				var msg = new Message("CIAPI_CHAT_DISPLAYED",{ 
					"customerName":displayedParams.customerName,
                    "openerScripts":displayedParams.openerScripts,
                    "defaultAgentAlias":displayedParams.defaultAgentAlias,
                });

                if(displayedParams.previousMessagesCb) {
                	var pMsgs = new Message("CIAPI_CHAT_PREVIOUS_MSGS");
                	pMsgs.setCallback(displayedParams.previousMessagesCb,false);
                	dynamicCBQueue.push(pMsgs);
                		
                }
                if(displayedParams.disconnectCb) {
                	var dMsg = new Message("CIAPI_CHAT_DISCONNECTED");
                	dMsg.setCallback(displayedParams.disconnectCb,false);
                	dynamicCBQueue.push(dMsg);
                		
                }
                if(displayedParams.reConnectCb) {
                	var rMsg = new Message("CIAPI_CHAT_RECONNECTED");
                	rMsg.setCallback(displayedParams.reConnectCb,false);
                	dynamicCBQueue.push(rMsg);
                		
                }
                if(displayedParams.failedCb) {
                	var fMsg = new Message("CIAPI_CHAT_FAILED");
                	fMsg.setCallback(displayedParams.failedCb,false);
                	dynamicCBQueue.push(fMsg);
                		
                }

                fireMesageToBridge(msg);
			},
			/**
			 * @typedef {Object<string:string>} engagementStatus			
			 * @property {string} engagementStatus.messageType - request type
			 * @property {string} engagementStatus.statusType - request status
			 * @property {number} engagementStatus.httpStatus - http status
			 */
			/**
			 * Fires upon receiving the response from backend regarding the creation of engagement session
			 * @typedef {function(engagementStatus):void} engageStatusCB
			 * @callback
			 * @param {engagementStatus} status
			 */
			 /**
			 * @function
			 * @name engageChat
			 * @param {string} text - initial text that is send you agent upon creation of the engagement
			 * @param {engageStatusCB} callback - callback that is fired upon receving a response for starting an engagment
			 */
			/** Allowing client Chat interface to start an engagment
			 * @property {engageChat} CIAPI.engageChat
			 */
			engageChat:function(initialMessage, callback) {
				var msg = new Message("CIAPI_ENGAGED_CHAT",initialMessage);
				if(callback) {
					msg.setCallback(callback);
                	dynamicCBQueue.push(msg);
				}

				fireMesageToBridge(msg);
			},
			/**
			 * Fires when a new message from backend
			 * @typedef {function(object):void} getMessageCB
			 * @callback
			 * @param {object} message
			 */
			/** Allowing client CI to listen to agent messages
			 * @property {function(getMessageCB):void} CIAPI.getMessages
			 */
			getMessages:function(callback) {
				var msg = new Message("GET_CIAPI_MESSAGES");
				if(callback) {
					msg.setCallback(callback,false);
                	dynamicCBQueue.push(msg);
				}

				fireMesageToBridge(msg);
				
			},
			/** Allowing client CI close the chat 
			 * @property {function():void} CIAPI.closeChat
			 */
			closeChat:function(){
				var msg = new Message("CLOSE_CIAPI_CHAT");
				fireMesageToBridge(msg);
				dynamicCBQueue = [];
			},
		 /**
		  * Allow client to close Chat with confirmation if user is engaged
		  *  @property {function():void} CIAPI.confirmAndClose
      */
		 confirmAndClose: function () {
				 var msg = new Message('CLOSE_WITH_CONFIRM');
				 fireMesageToBridge(msg);
				 dynamicCBQueue = [];
		 },
			/** Allowing client CI to send new customer mesage 
			 * @property {function(string):void} CIAPI.sendMessage
			 */
			sendMessage:function(msg) {
				var msg1 = new Message("SEND_CIAPI_MESSAGE",msg);
				fireMesageToBridge(msg1);
			},
			/** Allowing client CI to send customer activity message - activityType: startTyping | stopTyping | minimize | restore
			 * @property {function(string):void} CIAPI.sendActivityMessage
			 */
			sendActivityMessage:function(type){
				var msg2 = new Message("SEND_CIAPI_ACTIVITY",type);
				fireMesageToBridge(msg2);
			},
			/** Allowing client CI to request the transcript in an email
			 * @property {function(string):void} CIAPI.requestEmailTranscript
			 */
			requestEmailTranscript:function(emailAddress){
				var msg3 = new Message("REQUEST_CIAPI_TRANSCRIPT",emailAddress);
				fireMesageToBridge(msg3);
			},
			/**
			 * Fires with the chat progress state 
			 * @typedef {function(boolean):void} chatProgressCB
			 * @callback
			 * @param {boolean} state
			 */
			/** Allowing client CI to  retrieve the chat progress state
			 * @property {function(chatProgressCB):void} CIAPI.isChatInProgress
			 */
			isChatInProgress:function(callback){
				var msg4 = new Message("GET_CIAPI_CHAT_STATE");
				if(callback) {
					msg4.setCallback(callback);
                	dynamicCBQueue.push(msg4);
				}
				fireMesageToBridge(msg4);
			},
			/**
			 * Fires with the chat progress state 
			 * @typedef {function(Array.<string>):void} getOpenerCB
			 * @callback
			 * @param {Array.<string>} openers - array of string openers
			 */
			/** Allowing client CI to request the openers configured in portal
			 * @property {function(getOpenerCB):void} CIAPI.getOpenerScripts
			 */
			getOpenerScripts:function(callback, openerID) {
				var msg5 = new Message("GET_CIAPI_OPENERS", openerID);
				if(callback) {
					msg5.setCallback(callback);
                	dynamicCBQueue.push(msg5);
				}
				fireMesageToBridge(msg5);
			},
			/** Allowing client CI send custom data pass
			 * @property {function(object):void} CIAPI.sendDataPass
			 */
			sendDataPass:function(dpObject){
				if(typeof dpObject != "object"){
					logError("sendDataPass only accepts Object as its argument.");
					return;
				}
				var msg6 = new Message("SEND_CIAPI_DATAPASS",dpObject);
				fireMesageToBridge(msg6);
			},
			/**
			 * Fires with the chat progress state 
			 * @typedef {function(string):void} vaLinkClickCB
			 * @callback
			 * @param {string} text - text that needs to be displayed in the chat window
			 */
			/** Allowing client CI to pass the processing of virtual agent dialoges
			 * @property {function(Event,vaLinkClickCB):void} CIAPI.sendVALinkMessage
			 */
			sendVALinkMessage:function(event, customerMsgCB) {
				var eventTarget = event.target || event.srcElement;
				var el;

				//if any element (i.e. "IMG") is wrapped in "A", it should be handled in the same way.
				//thus we are looking for the nearest "A" and working with its data-attributes.
				if (eventTarget.tagName == "A") {
					el = eventTarget;
				} else {
					el = findEl(eventTarget, event.currentTarget);
				}

				function findEl(el, currTarget) {
					while (el.parentNode && el != currTarget) {
						el = el.parentNode;
						if (el.tagName === "A") {
							return el;
						}
					}
					return null;
				}

				if (!el) {
					return;
				}

				// according to Nuance's VA service specification 'data-vtz-jump' attr exists only at dialog links,
				// so we can determine these links by checking this attribute
				/** @type {string} */
				var vtzJump = el.getAttribute("data-vtz-jump");

				// according to Nuance's VA service specification external web links contains
				// "data-vtz-link-type" attribute equal to Web,
				// and "data-vtz-browse" attr with URL inside.
				/** @type {string} */
				var linkType = el.getAttribute("data-vtz-link-type");
				/** @type {string} */
				var vtzBrowse = el.getAttribute("data-vtz-browse");
				/** @type {string} */
				var text;
				/** @type {boolean} */
				var hiddenMessage = false;


				if (linkType == "Web" && vtzBrowse) {
					// according to Nuance's VA service specification for links with 'data-vtz-browse' attr,
					// in addition to this navigation, the caller should call the web service sending ##Url#url value as the UserText
					text = "##Url#" + vtzBrowse;
					hiddenMessage = true;
					// per RTDEV-21637, TalkAgentRequest.UserText should be limited to 100 chars.
					text = text.substring(0, 100);
				} else if (linkType == "Dialog") {
					text = el.text;
					if(custMsgCb) {
						custMsgCb(text);
					}
					if(event.preventDefault) {
						event.preventDefault();
					} else event.returnValue = false;
				} else if (event.type == "touchend" && event.target.href && event.target.href != "") {
					event.preventDefault();
					/* A timeout is necessary here, because a simultaneous call to VA and url change is resulting in a network error when
					 communicating with VA and does a retry which sometimes is resulting in  duplicate requests. Note this is observed only iphones*/
					window.setTimeout(function() {
						window.parent.location.href =  event.target.href;
					}, 1000);

				}
				else {
					return false;
				}

				var msgObj = {};
				msgObj.text = text;
				msgObj.attributes = {};
				

				var elAttributes = el.attributes;
				for (var i = 0; i < elAttributes.length; i++) {
					var name = elAttributes[i].name;
					if (name.startsWith("data-vtz")) {
						msgObj.attributes[name.replace("data-", '')] = elAttributes[i].value;
					}
				}
				var msg = new Message("SEND_CIAPI_VA_LINK",msgObj);

				fireMesageToBridge(msg);
			},
			/** Allowing client CI to pass rich media message 
			 * @property {function(string,object):void} CIAPI.sendRichContentMessage
			 */
			sendRichContentMessage: function(text, data) {
				var msg = new Message("SEND_CIAPI_RICH_MSG",{"text":text,"data":data});
				fireMesageToBridge(msg);
			},
			/**
			 * Fires with all previous conversation messages
			 * @typedef {function(Array.<object>):void} previousConvCB
			 * @callback
			 * @param {Array.<object>} text - Each object in the array is a conversation
			 */
			/** Allowing client CI to retreive previous conversation transcript for async messaging
			 * @property {function(previousConvCB):void} CIAPI.getPreviousAsyncTranscript
			 */
			getPreviousAsyncTranscript:function(callback) {
				var msg = new Message("GET_CIAPI_PREV_CONV");
				if(callback) {
					msg.setCallback(callback);
                	dynamicCBQueue.push(msg);
				}
				fireMesageToBridge(msg);
			},
			/**
			 * Fires with the state of last conversation
			 * @typedef {function(boolean):void} lastConvCB
			 * @callback
			 * @param {boolean} state - Each object in the array is a conversation
			 */
			/** Allowing client CI to retreive the state of last conversation
			 * @property {function(lastConvCB):void} CIAPI.isLastConversationActive
			 */
			isLastConversationActive:function(callback){
				var msg = new Message("GET_CIAPI_PREV_CONV_STATE");
				if(callback) {
					msg.setCallback(callback);
                	dynamicCBQueue.push(msg);
				}
				fireMesageToBridge(msg);
			},
			/**
			 * @typedef {function(object):void} unReadCB
			 * @callback
			 * @param {object} countObj - unread count
			 */
			/** Allowing client CI to get the unread messages of an active async chat
			 * @property {function(unReadCB):void} CIAPI.isLastConversationActive
			 */
			getAsyncUnReadMsgCount:function(ruleID, callback) {
				var msg = new Message("GET_CIAPI_ASYNC_UNREAD",ruleID);
				if(callback) {
					msg.setCallback(callback);
                	dynamicCBQueue.push(msg);
				}
				fireMesageToBridge(msg);
			},
			/**
			 * @typedef {function(Status):void} proactiveCB
			 * @callback
			 * @param {Status} statusObj - status of backend request to create proactive chat 
			 */
			/** Allowing client javascript to watch for proactive chat
			 * @property {function(proactiveCB):void} CIAPI.whenProactiveLaunch
			 */
			whenProactiveLaunch:function(callback){
				var msg = new Message("PROACTIVE_CHAT_LAUNCH");
				if(callback) {
					msg.setCallback(callback);
                	dynamicCBQueue.push(msg);
				}
			},
			/**
			 * @typedef {function(object):void} minCB
			 * @callback
			 * @param {object} minStatusObj - status of minimized status and count of messages retrieved during minimzed state 
			 */
			/** Allowing client javascript detect if chat was minimized before a page refresh
			 * @property {function(minCB):void} CIAPI.checkIfMinimized
			 */
			checkIfMinimized:function(callback) {
				var msg = new Message("IS_MINIMIZED");
				if(callback) {
					msg.setCallback(callback);
                	dynamicCBQueue.push(msg);
				}
				fireMesageToBridge(msg);	
			}

			
		}


	};

}();




nuan_websdk_bootstrap.js
